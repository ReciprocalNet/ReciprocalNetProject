/*
 * Reciprocal Net project
 * 
 * RequestCache.java
 * 
 * 15-Jun-2004: midurbin wrote first draft
 * 29-Jun-2004: midurbin replaced the generic put/get methods with ones for
 *              repositoryFiles and others for its ticket
 * 20-Aug-2004: midurbin altered comments to assert that this cache never loses
 *              entries
 * 20-Oct-2004: midurbin added getSiteInfo() and putSiteInfo()
 * 30-Nov-2004: midurbin added getLocalSiteInfo() and putLocalSiteInfo()
 * 15-Aug-2005: midurbin added getSearchMatches() and putSearchMatches()
 * 27-Sep-2005: midurbin added getNextAutoLocalLabId(), putNextAutoLocalLabId()
 *              and the constants, AUTO_LOCAL_LAB_IDS_EXHAUST and
 *              AUTO_LOCAL_LAB_IDS_DISABLED
 * 17-Feb-2006: jobollin added removeFullSampleInfo()
 */

package org.recipnet.site.wrapper;

import java.util.HashMap;
import java.util.Map;

import javax.servlet.ServletRequest;

import org.recipnet.site.shared.LocalTrackingConfig;
import org.recipnet.site.shared.RepositoryFiles;
import org.recipnet.site.shared.SearchParams;
import org.recipnet.site.shared.db.FullSampleInfo;
import org.recipnet.site.shared.db.LabInfo;
import org.recipnet.site.shared.db.ProviderInfo;
import org.recipnet.site.shared.db.SampleHistoryInfo;
import org.recipnet.site.shared.db.SampleInfo;
import org.recipnet.site.shared.db.SiteInfo;
import org.recipnet.site.shared.db.UserInfo;
import org.recipnet.site.shared.search.SearchMatches;

/**
 * This is a simple class that implements very specific caches that have
 * request scope.  Due to the nature of some objects and the organization of
 * some JSPs, simple caching even for a single request saves time-consuming
 * roundtrips to core.  Items put into the cache are GUARANTEED to be present
 * for the duration of its existance unless explicitly removed.
 */
public abstract class RequestCache {

    /**
     * Gets the {@code LocalTrackingConfig} object for the lab described
     * by the given labId.  The current implementation maintains a request
     * scope cache of these objects.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param labId the id of the lab for which a
     *     {@code LocalTrackingConfig} object is being requested or null
     *     if it is not yet cached.
     *     
     * @return the requested {@code LocalTrackingConfig} object or null
     */
    public static LocalTrackingConfig getLTC(ServletRequest request,
            int labId) {
        Map<Object, Object> cache = RequestCache.getCache("ltcCache", request);
        
        return (LocalTrackingConfig) cache.get(Integer.valueOf(labId));
    }

    /**
     * Puts the {@code LocalTrackingConfig} object into a request scope
     * cache, using its labId as the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param ltc the {@code LocalTrackingConfig} object
     */
    public static void putLTC(ServletRequest request,
            LocalTrackingConfig ltc) {
        Map<Object, Object> cache = RequestCache.getCache("ltcCache", request);
        
        cache.put(Integer.valueOf(ltc.labId), ltc);
    }

    /**
     * Gets the {@code SampleInfo} object for the sample identified by the
     * given sampleId.  The current implementation maintains a request scope
     * cache of these objects.  The key is generated from the sampleId followed
     * by a hyphen and the sampleHistoryId.  For the current version of the
     * sample, either its historyId or
     * {@code SampleHistoryInfo.INVALID_SAMPLE_HISTORY_ID} are valid
     * requests as {@code putSampleInfo()} will cache it as both.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param sampleId the id of the requested sample (forms the cache key)
     * @param sampleHistoryId the history id of the request sample (forms the
     *     cache key)
     *     
     * @return the requested {@code SampleInfo} object or null
     */
    public static SampleInfo getSampleInfo(ServletRequest request,
            int sampleId, int sampleHistoryId) {
        Map<Object, Object> cache
                = RequestCache.getCache("sampleCache", request);
        
        return (SampleInfo) cache.get(
                new String(sampleId + "-" + sampleHistoryId));        
    }

    /**
     * Puts the {@code SampleInfo} object into a request scope cache using
     * an a {@code String} generated by concatinating its id a hyphen and
     * its historyId as the key.  In the case where the sample is the most
     * recent version, it will be cached twice, once using its history id, and
     * again using {@code INVALID_SAMPLE_HISTORY_ID} to generate the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param sampleInfo the {@code SampleInfo}
     */
    public static void putSampleInfo(ServletRequest request, 
                SampleInfo sampleInfo) {
        Map<Object, Object> cache
                = RequestCache.getCache("sampleCache", request);
        
        cache.put(new String(sampleInfo.id + "-" + sampleInfo.historyId),
                sampleInfo);
        if (sampleInfo.isMostRecentVersion()) {
            cache.put(new String(sampleInfo.id + "-"
                    + SampleHistoryInfo.INVALID_SAMPLE_HISTORY_ID),
                    sampleInfo);
        }
    }

    /**
     * Gets the {@code UserInfo} object for the user identified by the
     * given userId.  The current implementation maintains a request scope
     * cache of these objects for which the userId is the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param userId the id of the requested user
     * 
     * @return the requested {@code UserInfo} object or null
     */
    public static UserInfo getUserInfo(ServletRequest request, int userId) {
        Map<Object, Object> cache = RequestCache.getCache("userCache", request);
        
        return (UserInfo) cache.get(Integer.valueOf(userId));        
    }

    /**
     * Puts the {@code UserInfo} object into a request scope cache using
     * its userId as the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param userInfo the {@code UserInfo} object
     */
    public static void putUserInfo(ServletRequest request, UserInfo userInfo) {
        Map<Object, Object> cache = RequestCache.getCache("userCache", request);
        
        cache.put(Integer.valueOf(userInfo.id), userInfo);
    }

    /**
     * Gets the {@code ProviderInfo} object for the provider identified by
     * the given providerId.  The current implementation maintains a request
     * scope cache of these objects for which the providerId is the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param providerId the id of the requested provider
     * 
     * @return the requested {@code ProviderInfo} object or null
     */
    public static ProviderInfo getProviderInfo(ServletRequest request,
            int providerId) {
        Map<Object, Object> cache
                = RequestCache.getCache("providerCache", request);
        
        return (ProviderInfo) cache.get(Integer.valueOf(providerId));        
    }

    /**
     * Puts the {@code ProviderInfo} object into a request scope cache
     * using its providerId as the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param providerInfo the {@code ProviderInfo} object
     */
    public static void putProviderInfo(ServletRequest request,
                ProviderInfo providerInfo) {
        Map<Object, Object> cache
                = RequestCache.getCache("providerCache", request);
        
        cache.put(Integer.valueOf(providerInfo.id), providerInfo);
    }

    /**
     * Gets the {@code LabInfo} object for the lab identified by the
     * given labId.  The current implementation maintains a request scope
     * cache of these objects for which the labId is the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param labId the id of the requested lab
     * 
     * @return the requested {@code LabInfo} object or null
     */
    public static LabInfo getLabInfo(ServletRequest request, int labId) {
        Map<Object, Object> cache = RequestCache.getCache("labCache", request);
        
        return (LabInfo) cache.get(Integer.valueOf(labId));        
    }

    /**
     * Puts the {@code LabInfo} object into a request scope cache using
     * its labId as the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param labInfo the {@code LabInfo} object
     */
    public static void putLabInfo(ServletRequest request, LabInfo labInfo) {
        Map<Object, Object> cache = RequestCache.getCache("labCache", request);
        
        cache.put(Integer.valueOf(labInfo.id), labInfo);
    }

    /**
     * Gets the {@code SiteInfo} object for the local site if it has been
     * previously cached by a call to {@code putLocalSiteInfo()}.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute.
     *     
     * @return the {@code SiteInfo} object for the local site or null
     */
    public static SiteInfo getLocalSiteInfo(ServletRequest request) {
        return (SiteInfo) request.getAttribute("localSiteInfo");
    }

    /**
     * Puts the {@code SiteInfo} object into a request scope cache (via a
     * call to {@code putSiteInfo()}) and stores an additional reference
     * to it that may be retrieved by {@code getLocalSiteInfo()} without
     * knowledge of the site Id.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param siteInfo the {@code SiteInfo} that is known to represent the
     *     local site
     */
    public static void putLocalSiteInfo(ServletRequest request,
            SiteInfo siteInfo) {
        request.setAttribute("localSiteInfo", siteInfo);
        putSiteInfo(request, siteInfo);
    }

    /**
     * Gets the {@code SiteInfo} object for the site identified by the
     * given siteId.  The current implementation maintains a request scope
     * cache of these objects.  The key is simply the siteId.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param siteId the id of the requested site (forms the cache key)
     * 
     * @return the requested {@code SiteInfo} object or null
     */
    public static SiteInfo getSiteInfo(ServletRequest request, int siteId) {
        Map<Object, Object> cache = RequestCache.getCache("siteCache", request);
        
        return (SiteInfo) cache.get(String.valueOf(siteId));        
    }

    /**
     * Puts the {@code SiteInfo} object into a request scope cache using
     * an a {@code String} representation of the site id as the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param siteInfo the {@code SiteInfo}
     */
    public static void putSiteInfo(ServletRequest request, 
                SiteInfo siteInfo) {
        Map<Object, Object> cache = RequestCache.getCache("siteCache", request);
        
        cache.put(String.valueOf(siteInfo.id), siteInfo);
    }

    /**
     * Gets the {@code FullSampleInfo} object for the sample identified by
     * the given sampleId.  The current implementation maintains a request
     * scope cache of these objects for which the sampleId is the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param sampleId the id of the sample whose {@code FullSampleInfo}
     *     is being requested.
     *     
     * @return the requested {@code FullSampleInfo} object or null
     */
    public static FullSampleInfo getFullSampleInfo(ServletRequest request,
            int sampleId) {
        Map<Object, Object> cache
                = RequestCache.getCache("fullSampleCache", request);
        
        return (FullSampleInfo) cache.get(Integer.valueOf(sampleId));        
    }

    /**
     * Puts the {@code FullSampleInfo} object into a request scope cache
     * using its id as the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param fullSampleInfo the {@code FullSampleInfo} object
     */
    public static void putFullSampleInfo(ServletRequest request,
           FullSampleInfo fullSampleInfo) {
        Map<Object, Object> cache
                = RequestCache.getCache("fullSampleCache", request);
        
        cache.put(Integer.valueOf(fullSampleInfo.id), fullSampleInfo);
    }

    /**
     * Removes any {@code FullSampleInfo} cached for the specified sample ID
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param sampleId the id of the sample whose {@code FullSampleInfo}
     *     is to be removed from the cache.
     */
    public static void removeFullSampleInfo(ServletRequest request,
            int sampleId) {
        Map<Object, Object> cache
                = RequestCache.getCache("fullSampleCache", request);
        
        cache.remove(Integer.valueOf(sampleId));
        
        return;        
    }
    
    /**
     * Gets the {@code RepositoryFiles} object for the sample version
     * identified by the given sampleId and sampleHistoryId.  The current
     * implementation maintains a request scope cache of these objects for
     * which the sampleId concatinated with a hyphen and the sampleHistoryId is
     * the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param sampleId the id of the requested sample (forms the cache key)
     * @param sampleHistoryId the history id of the request sample (forms the
     *     cache key)
     *     
     * @return the requested {@code FullSampleInfo} object or null
     */
    public static RepositoryFiles getRepositoryFiles(ServletRequest request,
            int sampleId, int sampleHistoryId) {
        Map<Object, Object> cache
                = RequestCache.getCache("repositoryFilesCache", request);
        
        return (RepositoryFiles) cache.get(
                new String(sampleId + "-" + sampleHistoryId));        
    }

    /**
     * Puts the {@code RepositoryFiles} object into a request scope cache
     * using the sampleId and sampleHistoryId from the sample whose files are
     * included to create the key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param repositoryFiles the {@code RepositoryFiles} object
     */
    public static void putRepositoryFiles(ServletRequest request,
           RepositoryFiles repositoryFiles) {
        Map<Object, Object> cache
                = RequestCache.getCache("repositoryFilesCache", request);
        
        cache.put(new String(repositoryFiles.getSampleId() + "-"
                + repositoryFiles.getSampleHistoryId()), repositoryFiles);
    }

    /**
     * Gets the ticket number for the given {@code RepositoryFiles}
     * object or returns null if no ticket has been cached for that object.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param repositoryFiles the {@code RepositoryFiles} object to which
     *     the requested ticket belongs
     *     
     * @return an {@code Integer} whose value is the ticket number, or
     *     null if no ticket has been cached for this file listing
     */
    public static Integer getTicket(ServletRequest request,
            RepositoryFiles repositoryFiles) {
        Map<Object, Object> cache
                = RequestCache.getCache("ticketCache", request);
        
        return (Integer) cache.get(repositoryFiles);
    }

    /**
     * Puts the ticket for the given {@code RepositoryFiles} object into
     * a request scope cache.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param repositoryFiles the {@code RepositoryFiles} object to which
     *     the ticket belongs (used as the cache key)
     * @param ticket a ticket that has been granted on the given
     *     {@code RepositoryFiles} object.
     */
    public static void putTicket(ServletRequest request,
            RepositoryFiles repositoryFiles, int ticket) {
        Map<Object, Object> cache
                = RequestCache.getCache("ticketCache", request);
        
        cache.put(repositoryFiles, Integer.valueOf(ticket));
    }

    /**
     * Gets the {@code SearchMatches} object that contains information
     * about field matches between the given {@code SearchParams} and
     * {@code SampleInfo} from the request scope cache.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param searchParams the {@code SearchParams} defining the search
     * @param sampleInfo the {@code SampleInfo} whose matches with the
     *     search are in question
     *     
     * @return a {@code SearchMatches} object containing information about
     *     specific field matches between the sample and the search criteria
     */
    public static SearchMatches getSearchMatches(ServletRequest request,
            SearchParams searchParams, SampleInfo sampleInfo) {
        Map<Object, Object> cache
                = RequestCache.getCache("searchMatchCache", request);
        
        return (SearchMatches) cache.get(searchParams + "-" + sampleInfo.id);
    }

    /**
     * Puts the {@code SearchMatches} object that contains information
     * about field matches between the given {@code SearchParams} and
     * {@code SampleInfo} into a request scope cache.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param searchMatches a {@code SearchMatches} object containing
     *     information about specific field matches between the sample and the
     *     search criteria
     * @param searchParams the {@code SearchParams} defining the search
     * @param sampleInfo the {@code SampleInfo} whose matches with the
     *     search are in question
     */
    public static void putSearchMatches(ServletRequest request,
            SearchMatches searchMatches, SearchParams searchParams,
            SampleInfo sampleInfo) {
        Map<Object, Object> cache
                = RequestCache.getCache("searchMatchCache", request);
        
        cache.put(searchMatches, searchParams + "-" + sampleInfo.id);
    }

    /**
     * A key value for the 'autoLocalLabCache' representing the case where
     * autogeneration has not been enabled for a particular lab.
     */
    public static final String AUTO_LOCAL_LAB_IDS_DISABLED = "disabled";

    /**
     * A key value for the 'autoLocalLabCache' representing the case where all
     * possible autogenerated id values have been used.
     */
    public static final String AUTO_LOCAL_LAB_IDS_EXHAUSTED
            = "(numbers exhausted)";

    /**
     * Gets the next automatically generated local lab id for a new sample from
     * the given lab.  The value returned by this method should not be treated
     * as the value until it has been compared against both key values:
     * {@code AUTO_LOCAL_LAB_IDS_DISABLED} and
     * {@code AUTO_LOCAL_LAB_IDS_EXHAUSTED}.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param labId the id of the lab whose next automatically generated local
     *     lab id is requested
     *     
     * @return the next automatic local lab id for samples originating from the
     *     given lab, null if the value is not cached or one of the key values
     *     defined for this cache.
     */
    public static String getNextAutoLocalLabId(ServletRequest request,
            int labId) {
        Map<Object, Object> cache
                = RequestCache.getCache("autoLocalLabCache", request);
        
        return (String) cache.get(Integer.valueOf(labId));
    }

    /**
     * Puts the next automatically generated local lab id for a new sample from
     * the given lab into a request scope cache.  To indicate special cases,
     * they key values defined for this cache may be inserted as the value for
     * a particular lab key.
     * 
     * @param request the current {@code ServletRequest}, to which this
     *     cache is an attribute
     * @param labId the id of the lab whose next automatically generated local
     *     lab id is requested
     * @param autoId the next autogenerated id, or null to indicate that
     *     autogeneration is not enabled
     */
    public static void putNextAutoLocalLabId(ServletRequest request, int labId,
            String autoId) {
        Map<Object, Object> cache
                = RequestCache.getCache("autoLocalLabCache", request);
        
        cache.put(Integer.valueOf(labId), autoId);
    }

    /**
     * Returns a {@code Map} that serves as the cache for a particular
     * name.  If no such {@code Map} exists, a new one is created and set as
     * an attribute to the provided {@code ServletRequest}.
     * 
     * @param name an identifier for the cache.  Must not be equal ot any other
     *     request attributes.
     * @param request the current {@code ServletRequest} object.
     * 
     * @return the named {@code Map}  
     */
    @SuppressWarnings("unchecked")
    private static Map<Object, Object> getCache(String name,
            ServletRequest request) {
        Map<Object, Object> cache
                = (Map<Object, Object>) request.getAttribute(name);
        
        if (cache == null) {
            cache = new HashMap<Object, Object>();
            request.setAttribute(name, cache);
        }
        
        return cache;
    }
}
