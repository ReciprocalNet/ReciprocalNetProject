/*
 * Reciprocal Net project
 * 
 * MessageFileAgent.java
 *
 * 12-Jul-2002: ekoperda wrote first draft
 * 26-Sep-2002: ekoperda moved class to the core.util package; used to be in
 *              the core package, changed class name to MessageFileAgent (used
 *              to be MessageFileDirectory), and performed a substantial recode
 * 08-Oct-2002: ekoperda added functions buildSentMessagesDocument() and
 *              buildReceivedMessagesDocument() and refactored code to use
 *              the SoapUtil class
 * 31-Oct-2002: ekoperda modified buildSentMessageDocument() to properly
 *              handle mismatched public and private sequence numbers, now
 *              requires three parameters instead of two
 * 22-Nov-2002: ekoperda added helper functions readStringFromFile(),
 *              writeStringToFile(), and copyFile(), and refactored existing
 *              code to use them
 * 21-Feb-2003: ekoperda added exception support throughout
 * 21-Mar-2003: ekoperda reordered logic in writeSentMessage() in an attempt to
 *              fix bug 794
 * 24-Mar-2003: ekoperda modified writeReceivedMessage() and 
 *              clearHeldMessage() to handle the case where a received-message 
 *              file already exists
 * 28-Mar-2003: ekoperda fixed bug #834 in buildSentMessagesDocument() and
 *              buildReceivedMessagesDocument()
 * 13-May-2003: midurbin fixed bug #817 buildMsgpakForSentMessages(),
 *              readSiteGrantFromMsgpak(), readStringFromFile(),
 *              writeStringToFile()
 * 07-Jan-2004: ekoperda moved class from org.recipnet.site.core.util package
 *              to org.recipnet.site.core.agent; changed package references due
 *              to source tree reorganization
 * 08-Apr-2004: midurbin added readSentMessageCheckSignature()
 * 16-Dec-2005: ekoperda rewrote file to to accommodate changes to 
 *              ReceivedMessageAgent, using modern coding conventions
 * 26-May-2006: reformatted the source; updated docs
 */

package org.recipnet.site.core.agent;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.security.Signature;
import java.security.SignatureException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;

import org.recipnet.site.OperationFailedException;
import org.recipnet.site.core.MessageDecodingException;
import org.recipnet.site.core.ResourceException;
import org.recipnet.site.core.ResourceNotAccessibleException;
import org.recipnet.site.core.ResourceNotFoundException;
import org.recipnet.site.core.msg.InterSiteMessage;
import org.recipnet.site.shared.SoapUtil;
import org.recipnet.site.shared.db.SiteInfo;
import org.xml.sax.SAXException;

/**
 * This agent of Site Manager's is responsible for storing inter-site message
 * files on the filesystem and retrieving them efficiently. Additionally, a
 * subset of this agent's functionality is utilized by the Coordinator software,
 * which also stores inter-site messages on the filesystem.
 * <p>
 * ISM's are stored on the filesystem in XML format, one file per message. Any
 * digital signatures that may be present on the messages are written to these
 * files verbatim. Files are named according to the suggestions of
 * {@code InterSiteMessage.getSuggestedFileName()}. Stored ISM's are grouped
 * into one of three directories depending upon their heritage. ISM's that were
 * generated by the local site are stored in the "sent messages directory".
 * ISM's that were generated by other sites and that have been processed by the
 * local site are stored in the "received messages directory". ISM's that were
 * generated by other sites and that have not yet been processed by the local
 * site are stored in the "held messages" directory. It is possible for this
 * agent to operate in a limited fashion without a received messages directory
 * or a held messages directory.
 * <p>
 * To facilitate the efficient searching and retrieving of ISM files, this agent
 * optionally stores message index information in a database table named
 * {@code storedIsms}. Each row of the table corresponds either to a message
 * file in the sent messages directory or a message file in the received
 * messages directory. Message files in the held messages directory are not
 * indexed. Access to the database is via a {@code Connection} object supplied
 * at construction time. To facilitate the sharing of this connection, this
 * agent always {@code synchronize}s on the connection before performing
 * database operations. If the caller chooses not to supply a database
 * connection at construction time, then no message file index is employed,
 * certain methods on this agent may perform slowly, and other methods may fail.
 * Such impaired methods are identified by appropriate source code comments.
 * <p>
 * Some methods on this class search through the stored messages and fetch a
 * subset of them that are suitable for delivery to a remote site. Decisions
 * about which ISM's are eligible for transmission to which remote sites are
 * delegated to the {@code TopologyAgent}. The caller supplies a reference to
 * the {@code TopologyAgent} at construction time.
 * <p>
 * This class is NOT thread-safe and must be synchronized upon.
 */
public class MessageFileAgent {
    /**
     * A special value that may be passed as an argument to some methods on this
     * class.
     */
    public static final long NO_LIMIT = Long.MAX_VALUE;

    /**
     * Site id number of the local site. This value is supplied by Site Manager
     * at construction time.
     */
    private int localSiteId;

    /**
     * A reference to the {@code TopologyAgent}, supplied by Site Manager at
     * construction time.
     */
    private TopologyAgent topologyAgent;

    /**
     * The database connection provided by {@code SiteManager} at construction
     * time. This value may be null, in which case database access is presumed
     * to be unavailable and some functionality of this class may be impaired.
     * Synchronize on this object before utilizing it.
     */
    private Connection conn;

    /** The filesystem directory where sent messages are stored. */
    private File sentMessagesDirectory;

    /**
     * The filesystem directory where received messages are stored, or null if
     * storage of received messages has not been enabled.
     */
    private File receivedMessagesDirectory;

    /**
     * The filesystem directory where held messages are stored, or null if
     * storage of held messages has not been enabled.
     */
    private File heldMessagesDirectory;

    /**
     * The only constructor.
     * 
     * @param localSiteId the id of the local site.
     * @param topologyAgent a reference to the Topology Agent.
     * @param conn a database connection that this class may utilize. This class
     *        will synchronize on this object before invoking any of the methods
     *        on it. This value may be null if database access is not available
     *        for some reason; however, in this case certain methods on this
     *        class may be nonfunctional.
     * @param sentMessagesDirectory identifies the sent-messages directory on
     *        the local filesystem. The directory must contain nothing but valid
     *        ISM files. This argument must not be null.
     * @param receivedMessagesDirectory identifies the received-messages
     *        directory on the local filesystem. The directory must contain
     *        nothing but valid ISM files. This may be null if storage of
     *        received messages is not desired.
     * @param heldMessagesDirectory identifies the held-messages directory on
     *        the local filesystem. This may be null if storage of held messages
     *        is not desired.
     * @throws ResourceNotAccessibleException with a nested {@code File} object
     *         if any of the three specified directories is unreadable,
     *         unwritable, or otherwise unusable.
     */
    public MessageFileAgent(int localSiteId, TopologyAgent topologyAgent,
            Connection conn, File sentMessagesDirectory,
            File receivedMessagesDirectory, File heldMessagesDirectory)
            throws ResourceNotAccessibleException {
        this.localSiteId = localSiteId;
        this.topologyAgent = topologyAgent;
        this.conn = conn;
        if (!sentMessagesDirectory.isDirectory()
                || !sentMessagesDirectory.canRead()
                || !sentMessagesDirectory.canWrite()) {
            throw new ResourceNotAccessibleException(sentMessagesDirectory);
        }
        this.sentMessagesDirectory = sentMessagesDirectory;
        if ((receivedMessagesDirectory != null)
                && (!receivedMessagesDirectory.isDirectory()
                        || !receivedMessagesDirectory.canRead()
                        || !receivedMessagesDirectory.canWrite())) {
            throw new ResourceNotAccessibleException(receivedMessagesDirectory);
        }
        this.receivedMessagesDirectory = receivedMessagesDirectory;
        if ((heldMessagesDirectory != null)
                && (!heldMessagesDirectory.isDirectory()
                        || !heldMessagesDirectory.canRead()
                        || !heldMessagesDirectory.canWrite())) {
            throw new ResourceNotAccessibleException(heldMessagesDirectory);
        }
        this.heldMessagesDirectory = heldMessagesDirectory;
    }

    /**
     * Prepares a caller-supplied {@code InterSiteMessage} object to be
     * "generated" by the local site by setting the message's sequence numbers
     * appropriately. Specifically, values in the fields
     * {@code ism.sourcePrevSeqNum} and {@code ism.sourceSeqNum} are overwritten
     * by this method. Because this function assigns a sequence number to the
     * ISM, it is not useful for link-local ISM's.
     * <p>
     * There is an implied timing dependency between this method and
     * {@code generateSentMessage()}: callers should organize their threads to
     * ensure that no two threads can invoke this method before one of them has
     * invoked {@code generateSentMessage()}; otherwise, duplicate sequence
     * numbers would be assigned to two sent-messages.
     * 
     * @param ism the {@code InterSiteMessage} object representing the message
     *        that eventually will be generated. The fields within the object
     *        should be mostly filled-in; however, this method will overwrite
     *        the {@code sourcePrevSeqNum} and {@code sourceSeqNum} fields with
     *        appropriate sequence numbers.
     * @throws IllegalStateException if no database connection was supplied to
     *         this class at construction time.
     * @throws OperationFailedException with a nested
     *         {@code java.security.SQLException} if a database error was
     *         encountered.
     */
    public void prepareSequenceNumbersForSentMessage(InterSiteMessage ism)
            throws OperationFailedException {
        if (this.conn == null) {
            throw new IllegalStateException();
        }
        synchronized (this.conn) {
            try {
                ism.sourcePrevSeqNum
                        = dbGetLastLocalSequenceNumberUsedForOtherSite(
                                ism.destSiteId, this.localSiteId, this.conn);
                ism.sourceSeqNum = dbGetNextLocalSequenceNumber(
                        this.localSiteId, this.conn);
            } catch (SQLException ex) {
                throw new OperationFailedException(ex);
            }
        }
    }

    /**
     * Takes a caller-supplied {@code InterSiteMessage} object and causes the
     * local site to "generate" it by archiving it on the local filesystem for
     * posterity. The ISM is converted to XML, is digitally signed, and then is
     * written to the filesystem in the sent-messages directory. If a database
     * connection was supplied to this object at construction time, the database
     * index table is updated to reflect the new ISM as well.
     * <p>
     * The caller is responsible for setting the ISM's sequence numbers
     * appropriately before calling this function; see
     * {@code prepareSequenceNumbersForSentMessage()} for one possible way of
     * accomplishing this. Note that there is an implied timing dependency
     * between this method and {@code prepareSequenceNumbersForSentMessage()};
     * see the latter method's documentation for a thread-safety note.
     * <p>
     * Because this function writes the ISM to the sent-messages directory, it
     * is not useful for link-local ISM's.
     * 
     * @return a String containing the XML representation of the newly-generated
     *         ISM. This string is identical to the contents of the sent-message
     *         file and is returned to the caller as a convenience only.
     * @param ism the {@code InterSiteMessage} object representing the message
     *        to be generated. Its fields are not altered by this method.
     * @param sigEngine a {@code Signature} engine that the caller has already
     *        initialized in verification mode with the local site's public key.
     * @throws IllegalArgumentException if {@code ism} is not suitable for
     *         generation by the local site.
     * @throws OperationFailedException with a nested {@code SignatureException}
     *         if the message could not be signed for some reason, or a nested
     *         {@code SQLException} if a database error occurred.
     * @throws ResourceException with a nested {@code IOException} and an
     *         {@code identifier} of type {@code File} if a low-level I/O error
     *         occured.
     */
    public String generateSentMessage(InterSiteMessage ism, Signature sigEngine)
            throws OperationFailedException, ResourceException {
        if ((ism.sourceSeqNum == InterSiteMessage.INVALID_SEQ_NUM)
                || ism.linkLocal || (ism.sourceSiteId != this.localSiteId)) {
            throw new IllegalArgumentException();
        }

        File file = null;
        try {
            // Sign the message and convert it to XML
            String ismAsXml = ism.toXmlAddSignature(sigEngine);

            // Write the XML to file.
            IsmIdentifier identifier = new IsmIdentifier(ism);
            file = calculateFileLocation(identifier);
            fileWrite(ismAsXml, file);

            // Update the database if one is accessible to us.
            if (this.conn != null) {
                synchronized (this.conn) {
                    dbAddUpdate(identifier, this.conn);
                }
            }

            return ismAsXml;
        } catch (SignatureException ex) {
            throw new OperationFailedException(ex);
        } catch (SQLException ex) {
            throw new OperationFailedException(ex);
        }
    }

    /**
     * Verifies that a specified sent-message file, as generated during a
     * caller's previous invocation of {@code generateSentMessage()}, is
     * readable by the local site and that the message's digital signature is
     * intact. Such a test might serve as a safeguard to prevent the local site
     * from accidently propagating unreadable messages. (Of course, the local
     * site would have genereated an unreadable ISM only in the case of a
     * programming bug.) This method has no effect and returns silently if the
     * specified ISM was verified to be readable. It throws an exception if the
     * specified ISM could not be verified.
     * 
     * @param localSiteId identifies the local site.
     * @param seqNum an ISM sequence number that identifies the particular
     *        sent-message file to be evaluated.
     * @param sigEngine a {@code Signature} engine that the caller has already
     *        initialized in verification mode with the local site's public key.
     * @param deleteFileOnError if this argument is true, and the sent-message
     *        file was successfully read from the filesystem but its contents
     *        could not be parsed as an ISM or the ISM could not be verified,
     *        the sent-message file is deleted. No files are deleted if this
     *        argument is false.
     * @throws IllegalStateException if no database connection was supplied to
     *         this class at construction time.
     * @throws MessageDecodingException with a nested
     *         {@code org.xml.sax.SAXException} and an {@code address} that's
     *         the name of the message file if the XML read from the message
     *         file could not be parsed or did not represent an
     *         {@code InterSiteMessage}.
     * @throws OperationFailedException if {@code DomUtil}'s transformation
     *         engine failed to execute the translation from XML to DOM tree.
     * @throws ResourceException with a nested {@code java.io.IOException} and
     *         an {@code identifier} of type {@code File} if the message XML
     *         could not be read from the specified message file.
     * @throws ResourceNotFoundException with a nested
     *         {@code java.io.FileNotFoundException} and an {@code identifier}
     *         of type {@code File} if the specified message file could not be
     *         found.
     */
    public void assertSentMessageIsReadable(int localSiteId, long seqNum,
            Signature sigEngine, boolean deleteFileOnError)
            throws MessageDecodingException, OperationFailedException,
            ResourceException, ResourceNotFoundException {
        MessageDecodingException exceptionEncountered = null;
        String xmlDoc = null;
        IsmIdentifier identifier = new IsmIdentifier(localSiteId, seqNum,
                InterSiteMessage.ALL_SITES);
        File file = calculateFileLocation(identifier);
        try {
            xmlDoc = fileRead(file);
            InterSiteMessage.fromXmlCheckSignature(xmlDoc, sigEngine);
        } catch (SAXException ex) {
            exceptionEncountered = new MessageDecodingException(
                    SiteInfo.INVALID_SITE_ID, file.getName(), xmlDoc, ex);
        } catch (SignatureException ex) {
            exceptionEncountered = new MessageDecodingException(
                    SiteInfo.INVALID_SITE_ID,
                    identifier.getSuggestedFileName(), xmlDoc, ex);
        } catch (MessageDecodingException ex) {
            exceptionEncountered = ex;
        }

        if (exceptionEncountered != null) {
            // The ISM could not be read back. This is an error.
            if (deleteFileOnError) {
                // Delete the message file from the filesystem and, if
                // possible, the associated row in the database index.
                file.delete();
                if (this.conn != null) {
                    synchronized (this.conn) {
                        try {
                            dbDelete(identifier, this.conn);
                        } catch (SQLException ex) {
                            throw new OperationFailedException(ex);
                        }
                    }
                }
            }
            throw exceptionEncountered;
        }
    }

    /**
     * Returns an array of InterSiteMessage's that represent every message
     * previously sent from the local site (that were stored in the sent
     * messages directory. The signatures on the messages (if present) are not
     * verified. The array of messages returned are in order by sequence number.
     * Throws an exception if the directory could not be listed, any message
     * file could not be parsed, or an I/O error occurred. This function is
     * present here only to support the special needs of the Coordinator
     * software.
     * 
     * @return an array of zero or more {@code InterSiteMessage} objects.
     * @throws MessageDecodingException with a nested
     *         {@code org.xml.sax.SAXException} and an {@code address} that's
     *         the name of the message file if the XML read from a message file
     *         could not be parsed or did not represent an
     *         {@code InterSiteMessage}.
     * @throws OperationFailedException if {@code DomUtil}'s transformation
     *         engine failed to execute the translation from XML to DOM tree.
     * @throws ResourceException with a nested {@code java.io.IOException} and
     *         an {@code identifier} of type {@code File} if the message XML
     *         could not be read from one of the message files.
     */
    public InterSiteMessage[] readAndDecodeAllSentMessages()
            throws MessageDecodingException, OperationFailedException,
            ResourceException {
        File[] files = sentMessagesDirectory.listFiles();
        Arrays.sort(files);
        InterSiteMessage isms[] = new InterSiteMessage[files.length];
        int i = 0;
        String ismAsXml = null;
        for (File file : files) {
            try {
                ismAsXml = fileRead(file);
                isms[i++] = InterSiteMessage.fromXml(ismAsXml);
            } catch (SAXException ex) {
                // Error parsing this XML into an InterSiteMessage
                throw new MessageDecodingException(SiteInfo.INVALID_SITE_ID,
                        file.getName(), ismAsXml, ex);
            }
        }
        return isms;
    }

    /**
     * Reads stored, previously-originated ISM's that are suitable for delivery
     * to a specified remote site (according to security rules). The caller
     * specifies filter critiera that describe which particular ISM's should be
     * read. The XML representations of matching, suitable ISM's are appended to
     * a caller-supplied {@code Collection}.
     * <p>
     * This function works properly even if no database connection was supplied
     * at construction time. In that case, because no index table is available,
     * this function may execute very slowly.
     * 
     * @return a count of the number of ISM's that matched the caller-specified
     *         criteria and were suitable for delivery to {@code destSiteId}.
     *         This value might be greater than the number of strings actually
     *         appended to {@code messagesAsXml}, depending upon the value of
     *         {@code maxMessages}.
     * @param destSiteId identifies the remote site to which the returned ISM's
     *        are to be sent. This argument acts as a filter criterion because
     *        private ISM's addressed to sites other than {@code destSiteId}
     *        will not be read.
     * @param requestedSiteId identifies the site whose originated ISM's are
     *        desired. This may be the local site, or a third site in the Site
     *        Network, but it probably wouldn't be useful for this value to
     *        equal {@code destSiteId}.
     * @param excludePublicSeqNumsUpTo identifies the sequence number of the
     *        last public ISM originated by {@code requestedSiteId} that should
     *        not be read. Thus, public ISM's originated by
     *        {@code requestedSiteId} with sequence numbers greater than this
     *        argument will be read. The special value
     *        {@code InterSiteMessage.INVALID_SEQ_NUM} indicates that no
     *        filtering of public ISM's should be performed.
     * @param excludePrivateSeqNumsUpTo identifies the sequence number of the
     *        last private ISM originated by {@code requestedSiteId} and
     *        addressed to {@code destSiteId} that should not be read. Thus,
     *        private ISM's originated by {@code requestedSiteId} and addressed
     *        to {@code destSiteId} with sequence numbers greater than this
     *        argument will be read. The special value
     *        {@code InterSiteMessage.INVALID_SEQ_NUM} indicates that no
     *        filtering of private ISM's should be performed.
     * @param maxMessages the maximum number of ISM's that this function should
     *        read and append to {@code messagesAsXml}. In the event that the
     *        number of ISM's matching caller-specified criteria is larger than
     *        this argument's value, this function will not read those ISM's
     *        having the highest sequence numbers. The special value
     *        {@code NO_LIMIT} indicates that this function should not limit the
     *        number of messages it reads.
     * @param messagesAsXml a caller-supplied {@code Collection} of
     *        {@code String} values. This function appends zero or more
     *        {@code String}'s to the collection by invoking
     *        {@code Collection.add()}. Each value this function adds to the
     *        collection is an XML document representing an ISM that was
     *        originated by the local site previously and that matches the
     *        caller's filter criteria. ISM's are added in order of ascending
     *        sequence number. The number of values added to this collection
     *        never is greater than {@code maxMessages}.
     * @throws IllegalStateException if {@code requestedSiteId} is not the local
     *         site, but no received messages directory was supplied at
     *         construction time.
     * @throws MessageDecodingException with a nested
     *         {@code org.xml.sax.SAXException} and an {@code address} that's
     *         the name of the message file if the XML read from the message
     *         file could not be parsed or did not represent an
     *         {@code InterSiteMessage}.
     * @throws OperationFailedException exception with a nested
     *         {@code SQLException} if a database error was encountered.
     * @throws ResourceException with a nested {@code java.io.IOException} and
     *         an {@code identifier} of type {@code File} if the message XML
     *         could not be read from one of the message files.
     */
    public long readMessagesSuitableForRemoteSite(int destSiteId,
            int requestedSiteId, long excludePublicSeqNumsUpTo,
            long excludePrivateSeqNumsUpTo, long maxMessages,
            Collection<String> messagesAsXml) throws MessageDecodingException,
            OperationFailedException, ResourceException {
        if ((requestedSiteId != this.localSiteId)
                && (this.receivedMessagesDirectory == null)) {
            throw new IllegalStateException();
        }
        if (this.conn != null) {
            // Do a database lookup. This should be relatively fast.
            try {
                synchronized (this.conn) {
                    Collection<IsmIdentifier> matchingIdentifiers
                            = dbSearchAndFetch(
                                    destSiteId, requestedSiteId,
                                    excludePublicSeqNumsUpTo,
                                    excludePrivateSeqNumsUpTo,
                                    maxMessages, this.conn, this.topologyAgent);
                    for (IsmIdentifier matchingIdentifier
                            : matchingIdentifiers) {
                        File file = calculateFileLocation(matchingIdentifier);

                        messagesAsXml.add(fileRead(file));
                    }
                    return dbSearchAndCount(destSiteId, requestedSiteId,
                            excludePublicSeqNumsUpTo,
                            excludePrivateSeqNumsUpTo, this.conn,
                            this.topologyAgent);
                }
            } catch (SQLException ex) {
                throw new OperationFailedException(ex);
            }
        } else {
            // Scan and parse each sent-message file. This can be very slow.
            return readMessagesSuitableForRemoteSiteByParsingFiles(destSiteId,
                    requestedSiteId, excludePublicSeqNumsUpTo,
                    excludePrivateSeqNumsUpTo, maxMessages, messagesAsXml);
        }
    }

    /**
     * Writes the specified message - which has been received over the Internet
     * from another site - to the held messages directory. The message's
     * authenticity and validity (parsability) should already have been verified
     * by the caller, but he should not have accepted or processed the message
     * yet. (Once the caller does accept the message, he should invoke
     * {@code clearHeldMessage()}.)
     * <p>
     * The message is passed to this function as XML (rather than a pure
     * {@code InterSiteMessage} object) for efficiency -- this XML should
     * contain the digital signature that was affixed by the message sender. The
     * caller should have parsed the message previously because the message's
     * {@code InterSiteMessage.sourceSiteId} and
     * {@code InterSiteMessage.sourceSeqNum} fields are passed to this method as
     * arguments. The method has no effect (fails silently) if an
     * identically-named message file already exists in the held-messages
     * directory.
     * 
     * @param ismAsXml the raw XML representation of the ISM that will be be
     *        written to file.
     * @param sourceSiteId identifies the site that originated the ISM.
     * @param sourceSeqNum the sequence number of the ISM, as parsed from it.
     * @throws IllegalStateException if no held messages directory was supplied
     *         to this agent at construction time.
     * @throws ResourceException with a nested {@code IOException} and an
     *         {@code identifier} of type {@code File} if a low-level I/O error
     *         occured.
     */
    public void writeHeldMessage(String ismAsXml, int sourceSiteId,
            long sourceSeqNum) throws ResourceException {
        if (this.heldMessagesDirectory == null) {
            throw new IllegalStateException();
        }
        File msgFile = new File(this.heldMessagesDirectory,
                InterSiteMessage.getSuggestedFileName(sourceSiteId,
                        sourceSeqNum));
        if (!msgFile.exists()) {
            fileWrite(ismAsXml, msgFile);
        }
    }

    /**
     * Clears the specified message from the held messages directory by deleting
     * the file. Normally a caller would invoke this function after a previous
     * call to writeHeldMessage(), once the caller had processed and accepted
     * the message.
     * 
     * @param ism the inter-site message whose held-message file is to be
     *        cleared.
     * @param copyToRecvDir if true, the message file is copied to the received
     *        messages directory prior to being deleted from the held messages
     *        directory. The copy is aborted silently if a corresponding message
     *        file already exists in the received messages directory.
     * @throws IllegalStateException if no held messages directory or no
     *         received messages directory was supplied to this agent at
     *         construction time.
     * @throws OperationFailedException with a nested {@code SQLException} if a
     *         database error occurred.
     * @throws ResourceException with a nested {@code IOException} and an
     *         {@code identifier} of type {@code File} if a low-level I/O error
     *         occured.
     */
    public void clearHeldMessage(InterSiteMessage ism, boolean copyToRecvDir)
            throws OperationFailedException, ResourceException {
        if ((heldMessagesDirectory == null) || (receivedMessagesDirectory == null)) {
            throw new IllegalStateException();
        }
        File heldMsgFile = new File(heldMessagesDirectory,
                ism.getSuggestedFileName());
        if (copyToRecvDir) {
            File recvMsgFile = new File(receivedMessagesDirectory,
                    ism.getSuggestedFileName());
            if (!recvMsgFile.exists() && heldMsgFile.exists()) {
                fileCopy(heldMsgFile, recvMsgFile);
                if (this.conn != null) {
                    // Update the database summary table.
                    try {
                        dbAddUpdate(new IsmIdentifier(ism), this.conn);
                    } catch (SQLException ex) {
                        throw new OperationFailedException(ex);
                    }
                }
            }
        }
        heldMsgFile.delete();
    }

    /**
     * Polls the held messages directory and fetches all of the messages stored
     * there. This function is intended to be called periodically by threads
     * that monitor the held messages directory. Optionally, held message files
     * older than a caller-specified limit are deleted during the scan.
     * 
     * @return an array of zero or more {@code String}'s, where each is the XML
     *         representation of a held message. Messages in the array are
     *         ordered by originating site id and then by sequence number.
     * @param maximumAge the maximum allowable age of held message files, in
     *        milliseconds. Files that are older than this limit are deleted
     *        silently. If this argument has the special value {@code NO_LIMIT},
     *        no age limit is enforced and no held message files are deleted.
     * @throws IllegalStateException if no held messages directory was supplied
     *         to this agent at construction time.
     * @throws ResourceException with a nested {@code IOException} and an
     *         {@code identifier} of type {@code File} if the message XML could
     *         not be read from one of the message files.
     */
    public String[] pollHeldMessages(long maximumAge) throws ResourceException {
        if (this.heldMessagesDirectory == null) {
            throw new IllegalStateException();
        }
        Collection<String> ismsAsXml = new ArrayList<String>();
        Date now = new Date();
        File[] files = heldMessagesDirectory.listFiles();
        Arrays.sort(files);
        for (File file : files) {
            if (now.getTime() - file.lastModified() > maximumAge) {
                // This message file is too old; just delete it silently.
                file.delete();
                continue;
            }
            ismsAsXml.add(fileRead(file));
        }
        return ismsAsXml.toArray(new String[0]);
    }

    /**
     * Deletes every stored message file in the sent messages directory, the
     * received messages directory (if any), and the held messages directory (if
     * any). Also deletes the message files index, if a database connection was
     * supplied to this agent at construction time. This function should be used
     * with care, as it renders the existing site permanently inoperable and has
     * <b><i>irrevocable consequences</i></b>.
     * 
     * @throws OperationFailedException with a nested {@code SQLException} if a
     *         low-level error was encountered while accessing the database.
     */
    public void deleteAll() throws OperationFailedException {
        // Clear all files from the message directories.
        if (this.receivedMessagesDirectory != null) {
            for (File file : this.receivedMessagesDirectory.listFiles()) {
                file.delete();
            }
        }
        if (this.heldMessagesDirectory != null) {
            for (File file : this.heldMessagesDirectory.listFiles()) {
                file.delete();
            }
        }
        for (File file : this.sentMessagesDirectory.listFiles()) {
            file.delete();
        }

        // Clear the database index, if database access is available.
        if (this.conn != null) {
            synchronized (this.conn) {
                try {
                    dbDeleteAll(this.conn);
                } catch (SQLException ex) {
                    throw new OperationFailedException(ex);
                }
            }
        }
    }

    /**
     * Rebuilds the message files index by scanning, reading, and parsing all
     * stored message files. It would be necessary to invoke this method during
     * a version upgrade or if the index was suspected of being corrupt, for
     * instance. This method can be quite long-running.
     * 
     * @throws IllegalStateException if a database connection was not supplied
     *         to this agent at construction time.
     * @throws OperationFailedException with a nested {@code SQLException} if a
     *         low-level error was encountered while accessing the database.
     */
    public void rebuildIsmIndex() throws OperationFailedException {
        if (this.conn == null) {
            throw new IllegalStateException();
        }
        synchronized (this.conn) {
            try {
                dbDeleteAll(this.conn);

                if (this.receivedMessagesDirectory != null) {
                    for (File file : this.receivedMessagesDirectory.listFiles()) {
                        InterSiteMessage ism = fileReadAndDecode(file);
                        dbAddUpdate(new IsmIdentifier(ism), this.conn);
                    }
                }
                for (File file : this.sentMessagesDirectory.listFiles()) {
                    InterSiteMessage ism = fileReadAndDecode(file);
                    dbAddUpdate(new IsmIdentifier(ism), this.conn);
                }
            } catch (SQLException ex) {
                throw new OperationFailedException(ex);
            }
        }
    }

    /**
     * Helper function that mimicks the specification of
     * {@code readMessagesSuitableForRemoteSite()} but does not require access
     * to a message files index in a database. Because this function scans,
     * reads, and parses all stored message files, it may execute quite slowly.
     * 
     * @return a count of the number of ISM's that matched the caller-specified
     *         criteria and were suitable for delivery to {@code destSiteId}.
     *         This value might be greater than the number of strings actually
     *         appended to {@code messagesAsXml}, depending upon the value of
     *         {@code maxMessages}.
     * @param destSiteId identifies the remote site to which the returned ISM's
     *        are to be sent. This argument acts as a filter criterion because
     *        private ISM's addressed to sites other than {@code destSiteId}
     *        will not be read.
     * @param requestedSiteId identifies the site whose originated ISM's are
     *        desired. This may be the local site, or a third site in the Site
     *        Network, but it probably wouldn't be useful for this value to
     *        equal {@code destSiteId}.
     * @param excludePublicSeqNumsUpTo identifies the sequence number of the
     *        last public ISM originated by {@code requestedSiteId} that should
     *        not be read. Thus, public ISM's originated by
     *        {@code requestedSiteId} with sequence numbers greater than this
     *        argument will be read. The special value
     *        {@code InterSiteMessage.INVALID_SEQ_NUM} indicates that no
     *        filtering of public ISM's should be performed.
     * @param excludePrivateSeqNumsUpTo identifies the sequence number of the
     *        last private ISM originated by {@code requestedSiteId} and
     *        addressed to {@code destSiteId} that should not be read. Thus,
     *        private ISM's originated by {@code requestedSiteId} and addressed
     *        to {@code destSiteId} with sequence numbers greater than this
     *        argument will be read. The special value
     *        {@code InterSiteMessage.INVALID_SEQ_NUM} indicates that no
     *        filtering of private ISM's should be performed.
     * @param maxMessages the maximum number of ISM's that this function should
     *        read and append to {@code messagesAsXml}. In the event that the
     *        number of ISM's matching caller-specified criteria is larger than
     *        this argument's value, this function will not read those ISM's
     *        having the highest sequence numbers. The special value
     *        {@code NO_LIMIT} indicates that this function should not limit the
     *        number of messages it reads.
     * @param messagesAsXml a caller-supplied {@code Collection} of
     *        {@code String} values. This function appends zero or more
     *        {@code String}'s to the collection by invoking
     *        {@code Collection.add()}. Each value this function adds to the
     *        collection is an XML document representing an ISM that was
     *        originated by the local site previously and that matches the
     *        caller's filter criteria. ISM's are added in order of ascending
     *        sequence number. The number of values added to this collection
     *        never is greater than {@code maxMessages}.
     * @throws MessageDecodingException with a nested
     *         {@code org.xml.sax.SAXException} and an {@code address} that's
     *         the name of the message file if the XML read from the message
     *         file could not be parsed or did not represent an
     *         {@code InterSiteMessage}.
     * @throws OperationFailedException with a nested {@code SQLException} if a
     *         database error was encountered.
     * @throws ResourceException with a nested {@code java.io.IOException} and
     *         an {@code identifier} of type {@code File} if the message XML
     *         could not be read from one of the message files.
     */
    private long readMessagesSuitableForRemoteSiteByParsingFiles(
            int destSiteId, int requestedSiteId, long excludePublicSeqNumsUpTo,
            long excludePrivateSeqNumsUpTo, long maxMessages,
            Collection<String> messagesAsXml) throws MessageDecodingException,
            OperationFailedException, ResourceException {
        long messagesFound = 0;
        long messagesReturned = 0;
        File[] files = requestedSiteId == this.localSiteId
                ? this.sentMessagesDirectory.listFiles()
                : this.receivedMessagesDirectory.listFiles();
        Arrays.sort(files);
        for (File file : files) {
            String ismAsXml = null;
            try {
                ismAsXml = fileRead(file);
                InterSiteMessage ism = InterSiteMessage.fromXml(ismAsXml);
                if (this.topologyAgent.isIsmEligibleForTransmissionTo(ism,
                        destSiteId, excludePublicSeqNumsUpTo,
                        excludePrivateSeqNumsUpTo)
                        && (ism.sourceSiteId == requestedSiteId)) {
                    messagesFound++;
                    if (messagesReturned < maxMessages) {
                        messagesAsXml.add(ismAsXml);
                        messagesReturned++;
                    }
                }
            } catch (SAXException ex) {
                // Error parsing this XML into an InterSiteMessage
                throw new MessageDecodingException(SiteInfo.INVALID_SITE_ID,
                        file.getName(), ismAsXml, ex);
            }
        }
        return messagesReturned;
    }

    /**
     * Helper function that calculates the filesystem location at which a
     * specified stored message file would exist.
     * 
     * @return a {@code File} object that identifies the stored message file's
     *         location. There is no guarantee that such a file actually exists.
     * @param identifier identifies the desired stored message.
     */
    private File calculateFileLocation(IsmIdentifier identifier) {
        return new File(
                identifier.isReceivedMessage(this.localSiteId)
                        ? this.receivedMessagesDirectory
                        : this.sentMessagesDirectory,
                identifier.getSuggestedFileName());
    }

    /**
     * Helper function that reads the specified file into memory, in its
     * entirety. The file is assumed to have been encoded using the UTF-8
     * character set.
     * 
     * @return a {@code String} representing the contents of the file, decoded
     *         from bytes to characters.
     * @param file identifies the file to be read.
     * @throws ResourceException with a nested {@code IOException} if an error
     *         was encountered while reading the file.
     * @throws ResourceNotFoundException with a nested
     *         {@code FileNotFoundException} if the specified {@code file} was
     *         not found.
     */
    private static String fileRead(File file) throws ResourceException {
        try {
            return SoapUtil.readEntireInputStream(new FileInputStream(file));
        } catch (FileNotFoundException ex) {
            throw new ResourceNotFoundException(file, ex);
        } catch (IOException ex) {
            throw new ResourceException(file, ex);
        }
    }

    /**
     * Helper function that reads a specified stored message file and decodes it
     * into an {@code InterSiteMessage} object. It is similar in concept to
     * {@code fileRead()} but goes one step further. Any digital signature that
     * might be present on the file is not verified.
     * 
     * @return an {@code InterSiteMessage} object, as constructed from the
     *         contents of {@code file}.
     * @param file identifies the stored message file to be read.
     * @throws MessageDecodingException with a nested
     *         {@code org.xml.sax.SAXException} and an {@code address} that's
     *         the name of the message file if the XML read from the message
     *         file could not be parsed or did not represent an
     *         {@code InterSiteMessage}.
     * @throws OperationFailedException if {@code DomUtil}'s transformation
     *         engine failed to execute the translation from XML to DOM tree.
     * @throws ResourceException with a nested {@code IOException} if an error
     *         was encountered while reading the file.
     * @throws ResourceNotFoundException with a nested
     *         {@code FileNotFoundException} if the specified {@code file} was
     *         not found.
     */
    private static InterSiteMessage fileReadAndDecode(File file)
            throws MessageDecodingException, OperationFailedException,
            ResourceException {
        String ismAsXml = null;
        try {
            ismAsXml = fileRead(file);
            return InterSiteMessage.fromXml(ismAsXml);
        } catch (SAXException ex) {
            // Error parsing this XML into an InterSiteMessage
            throw new MessageDecodingException(SiteInfo.INVALID_SITE_ID,
                    file.getName(), ismAsXml, ex);
        }
    }

    /**
     * Helper function that writes the specified string into the specified new
     * file (encoded using UTF-8 character set). Any file that may exist at
     * location {@code f} is overwritten.
     * 
     * @param s contains the data to be written to the file.
     * @param file identifies the file to be written to.
     * @throws ResourceException with a nested {@code IOException} and an
     *         {@code identifier} of type {@code File} if a low-level I/O error
     *         occured.
     */
    private static void fileWrite(String s, File file) throws ResourceException {
        Writer writer = null;
        try {
            writer = new OutputStreamWriter(new BufferedOutputStream(
                    new FileOutputStream(file)), "UTF-8");
            writer.write(s);
            writer.flush();
        } catch (IOException ex) {
            throw new ResourceException(file, ex);
        } finally {
            try {
                if (writer != null) {
                    writer.close();
                }
            } catch (IOException ex2) {
                throw new ResourceException(file, ex2);
            }
        }
    }

    /**
     * Helper function that copies the contents of one file to another.
     * 
     * @param source identifies the file that will be read from.
     * @param dest identifies the file that will be written to.
     * @throws ResourceException with a nested {@code IOException} and an
     *         {@code identifier} of type {@code File} if a low-level I/O error
     *         occurred.
     */
    private static void fileCopy(File source, File dest)
            throws ResourceException {
        FileInputStream is = null;
        FileOutputStream os = null;
        try {
            is = new FileInputStream(source);
            os = new FileOutputStream(dest);
            byte data[] = new byte[4096];
            int bytesThisOp;
            do {
                bytesThisOp = is.read(data, 0, 4096);
                if (bytesThisOp > 0) {
                    os.write(data, 0, bytesThisOp);
                }
            } while (bytesThisOp > 0);
            os.flush();
        } catch (IOException ex) {
            throw new ResourceException(dest, ex);
        } finally {
            try {
                if (os != null) {
                    os.close();
                }
                if (is != null) {
                    is.close();
                }
            } catch (IOException ex2) {
                throw new ResourceException(dest, ex2);
            }
        }
    }

    /**
     * Utility function that consults the database index and determines the next
     * unused sequence number for an ISM being generated by the local site.
     * 
     * @return a sequence number suitable for use in an
     *         {@code InterSiteMessage.sourcePrevSeqNum} field.
     * @param localSiteId identifies the local site.
     * @param conn the database connection to be used.
     * @throws SQLException if a database error was encountered.
     */
    private static long dbGetNextLocalSequenceNumber(int localSiteId,
            Connection conn) throws SQLException {
        Statement cmd = conn.createStatement();
        String sql = "SELECT MAX(sourceSeqNum) as sourceSeqNum"
                + " FROM storedIsms" + " WHERE sourceSiteId=" + localSiteId
                + ";";
        ResultSet rs = cmd.executeQuery(sql);
        if (!rs.next()) {
            // The db query didn't work for some reason.
            throw new SQLException();
        }
        long nextSeqNum = rs.getLong("sourceSeqNum") + 1;
        if (rs.wasNull()) {
            nextSeqNum = 0;
        }
        cmd.close();
        return nextSeqNum;
    }

    /**
     * Utility function that consults the database index and determines the
     * highest sequence number that is present on a locally-generated ISM that
     * was addressed to the specified remote site.
     * 
     * @return a sequence number suitable for use in an
     *         {@code InterSiteMessage.sourcePrevSeqNum} field. This may be the
     *         value {@code InterSiteMessage.INVALID_SEQ_NUM} if no such message
     *         addressed to the specified destination site has been originated
     *         by the local site previously.
     * @param destSiteId the desired remote site to which the ISM would have
     *        been addressed. The special value
     *        {@code InterSiteMessage.ALL_SITES} is valid here as well.
     * @param localSiteId identifies the local site.
     * @param conn the database connection to be used.
     * @throws SQLException if a database error was encountered.
     */
    private static long dbGetLastLocalSequenceNumberUsedForOtherSite(
            int destSiteId, int localSiteId, Connection conn)
            throws SQLException {
        Statement cmd = conn.createStatement();
        String sql = "SELECT MAX(sourceSeqNum) as sourceSeqNum"
                + " FROM storedIsms"
                + " WHERE sourceSiteId="
                + localSiteId
                + " AND "
                + (destSiteId == InterSiteMessage.ALL_SITES
                        ? "destSiteId IS NULL"
                        : "destSiteId=" + destSiteId) + " ;";
        ResultSet rs = cmd.executeQuery(sql);
        if (!rs.next()) {
            // The db query didn't work for some reason.
            throw new SQLException();
        }
        long lastSeqNum = rs.getLong("sourceSeqNum");
        if (rs.wasNull()) {
            lastSeqNum = InterSiteMessage.INVALID_SEQ_NUM;
        }
        cmd.close();
        return lastSeqNum;
    }

    /**
     * Utility function that searches the database for ISM's that match
     * caller-specified criteria and returns their identifiers. This operation
     * may be substantially faster than scanning the actual message files on the
     * filesystem. The number of matches returned by this function may be
     * limited by setting the {@code maxLimit} argument appropriately.
     * 
     * @return a collection of zero or more {@code IsmIdentifier} objects, where
     *         each identifies an ISM that matches the caller's search criteria.
     * @param destSiteId identifies the remote site to which the ISM's
     *        identified by this function might eventually be sent. This
     *        argument acts as a search criterion.
     * @param requestedSiteId identifies the site whose originated ISM's are
     *        desired. This argument acts as a search criterion.
     * @param excludePublicSeqNumsUpTo identifies the sequence number of the
     *        last public ISM originated by {@code requestedSiteId} that should
     *        not be found. Thus, public ISM's originated by
     *        {@code requestedSiteId} with sequence numbers greater than this
     *        argument will be found by the search. This argument acts as a
     *        search criterion unless it has the special value
     *        {@code InterSiteMessage.INVALID_SEQ_NUM}, in which case no
     *        sequence number filtering is performed for public ISM's.
     * @param excludePrivateSeqNumsUpTo identifies the sequence number of the
     *        last private ISM originated by {@code requestedSiteId} and
     *        addressed to {@code destSiteId} that should not be found. Thus,
     *        private ISM's originated by {@code requestedSiteId} and addressed
     *        to {@code destSiteId} with sequence numbers greater than this
     *        argument will be found by the search. This argument acts as a
     *        search criterion unless it has the special value
     *        {@code InterSiteMessage.INVALID_SEQ_NUM}, in which case no
     *        sequence number filtering is performed for private ISM's.
     * @param maxLimit the maximum number of ISM's that will be found by this
     *        search. In the event that the number of ISM's matching the
     *        caller's criteria is greater than this argument, those ISM's with
     *        the lowest sequence numbers are returned. The special value
     *        {@code NO_LIMIT} indicates that this method should not enforce any
     *        particular limit.
     * @param conn the database connection to be used.
     * @param topologyAgent a reference to the {@code TopologyAgent}. Decisions
     *        about which ISM's are allowed to be transmitted to which other
     *        sites are delegated to this object.
     * @throws SQLException if a database error was encountered.
     */
    private static Collection<IsmIdentifier> dbSearchAndFetch(int destSiteId,
            int requestedSiteId, long excludePublicSeqNumsUpTo,
            long excludePrivateSeqNumsUpTo, long maxLimit, Connection conn,
            TopologyAgent topologyAgent) throws SQLException {
        Collection<IsmIdentifier> matches = new ArrayList<IsmIdentifier>();
        Statement cmd = conn.createStatement();
        String sql = "SELECT * FROM storedIsms"
                + " WHERE sourceSiteId="
                + requestedSiteId
                + " AND "
                + topologyAgent.sqlForIsIsmEligibleForTransmissionTo(
                        destSiteId, excludePublicSeqNumsUpTo,
                        excludePrivateSeqNumsUpTo)
                + " ORDER BY sourceSiteId, sourceSeqNum"
                + (maxLimit != NO_LIMIT ? " LIMIT " + maxLimit : "") + ";";
        ResultSet rs = cmd.executeQuery(sql);
        int matchesAdded = 0;
        while (rs.next() && (matchesAdded < maxLimit)) {
            IsmIdentifier ismIdentifier = new IsmIdentifier(rs);
            matches.add(ismIdentifier);

            // The match-count limiting mechanism below deliberately is
            // redundant with the "LIMIT" term in the SQL string above.
            // Not all database engines support "LIMIT" as well as we might
            // hope. This counting mechanism guarantees that this function
            // never returns more matches than the caller desired.
            matchesAdded++;
        }
        cmd.close();
        return matches;
    }

    /**
     * Utility function similar in conception to {@code dbSearchAndFetch()} that
     * returns a count of matching ISM's rather than identifying the matches
     * individually. For some database engines, this operation might be
     * substantially quicker than fetching all the rows from the message files
     * index.
     * 
     * @return the number of stored messages that match the caller-specified
     *         search criteria.
     * @param destSiteId identifies the remote site to which the ISM's
     *        identified by this function might eventually be sent. This
     *        argument acts as a search criterion.
     * @param requestedSiteId identifies the site whose originated ISM's are
     *        desired. This argument acts as a search criterion.
     * @param excludePublicSeqNumsUpTo identifies the sequence number of the
     *        last public ISM originated by {@code requestedSiteId} that should
     *        not be found. Thus, public ISM's originated by
     *        {@code requestedSiteId} with sequence numbers greater than this
     *        argument will be found by the search. This argument acts as a
     *        search criterion unless it has the special value
     *        {@code InterSiteMessage.INVALID_SEQ_NUM}, in which case no
     *        sequence number filtering is performed for public ISM's.
     * @param excludePrivateSeqNumsUpTo identifies the sequence number of the
     *        last private ISM originated by {@code requestedSiteId} and
     *        addressed to {@code destSiteId} that should not be found. Thus,
     *        private ISM's originated by {@code requestedSiteId} and addressed
     *        to {@code destSiteId} with sequence numbers greater than this
     *        argument will be found by the search. This argument acts as a
     *        search criterion unless it has the special value
     *        {@code InterSiteMessage.INVALID_SEQ_NUM}, in which case no
     *        sequence number filtering is performed for private ISM's.
     * @param conn the database connection to be used.
     * @param topologyAgent a reference to the {@code TopologyAgent}. Decisions
     *        about which ISM's are allowed to be transmitted to which other
     *        sites are delegated to this object.
     * @throws SQLException if a database error was encountered.
     */
    private static long dbSearchAndCount(int destSiteId, int requestedSiteId,
            long excludePublicSeqNumsUpTo, long excludePrivateSeqNumsUpTo,
            Connection conn, TopologyAgent topologyAgent) throws SQLException {
        Statement cmd = conn.createStatement();
        String sql = "SELECT COUNT(*) AS count FROM storedIsms"
                + " WHERE sourceSiteId="
                + requestedSiteId
                + " AND "
                + topologyAgent.sqlForIsIsmEligibleForTransmissionTo(
                        destSiteId, excludePublicSeqNumsUpTo,
                        excludePrivateSeqNumsUpTo) + ";";
        ResultSet rs = cmd.executeQuery(sql);
        if (!rs.next()) {
            // The db query didn't work for some reason.
            throw new SQLException();
        }
        long count = rs.getLong("count");
        cmd.close();
        return count;
    }

    /**
     * Utility function that adds a row to the message files index in the
     * database to represent a newly-stored message file. In the event a
     * corresponding row already exists in the database, its contents are
     * updated.
     * 
     * @param ismIdentifier identifies the newly-stored message file.
     * @param conn the database connection to be used.
     * @throws SQLException if a database error was encountered.
     */
    private static void dbAddUpdate(IsmIdentifier ismIdentifier, Connection conn)
            throws SQLException {
        Statement cmd = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
                ResultSet.CONCUR_UPDATABLE);
        String sql = "SELECT * FROM storedIsms WHERE sourceSiteId="
                + ismIdentifier.sourceSiteId + " AND sourceSeqNum="
                + ismIdentifier.sourceSeqNum + " AND destSiteId="
                + ismIdentifier.destSiteId + ";";
        ResultSet rs = cmd.executeQuery(sql);
        if (rs.next()) {
            // Update the existing row. This probably won't ever happen
            // unless we add some new columns to the db table in the
            // future.
            ismIdentifier.dbStore(rs);
            rs.updateRow();
        } else {
            rs.moveToInsertRow();
            ismIdentifier.dbStore(rs);
            rs.insertRow();
        }
        cmd.close();
    }

    /**
     * Utility function that deletes a row from the message files index in the
     * database.
     * 
     * @param identifier identifies the stored message file whose index entry is
     *        to be deleted.
     * @param conn the database connection to be used.
     * @throws SQLException if a database error was encountered.
     */
    private static void dbDelete(IsmIdentifier identifier, Connection conn)
            throws SQLException {
        Statement cmd = conn.createStatement();
        String sql = "DELETE FROM storedIsms WHERE sourceSiteId="
                + identifier.sourceSiteId + " AND sourceSeqNum="
                + identifier.sourceSeqNum + ";";
        cmd.executeUpdate(sql);
        cmd.close();
    }

    /**
     * Utility function that deletes all rows from the message files index in
     * the database. This probably is useful only if we intend to rebuild the
     * table's contents from scratch.
     * 
     * @param conn the database connection to be used.
     * @throws SQLException if a database error was encountered.
     */
    private static void dbDeleteAll(Connection conn) throws SQLException {
        Statement cmd = conn.createStatement();
        cmd.executeUpdate("DELETE FROM storedIsms;");
        cmd.close();
    }

    /**
     * An internal class that identifies a particular stored message file. It is
     * structured similarly to a so-called "container object" in that the same
     * object also represents the contents of the stored message file's
     * corresponding row in the database table {@code storedIsms}. These
     * objects do not store an inter-site message's data proper, but merely
     * metadata regarding the inter-site message.
     */
    private static class IsmIdentifier {
        /**
         * Identifies the site that originated the corresponding stored message
         * file. This value is equivalent to
         * {@code InterSiteMessage.sourceSiteId}.
         */
        public int sourceSiteId;

        /**
         * The sequence number of the corresponding stored message file. This
         * value is equivalent to {@code InterSiteMessage.sourceSeqNum}.
         */
        public long sourceSeqNum;

        /**
         * Identifies the site to which the corresponding stored message was
         * addressed. This value is equivalent to
         * {@code InterSiteMessage.destSiteId}. In particular, the special
         * value InterSiteMessage.ALL_SITES indicates that the corresponding
         * stored message was addressed to all sites in the Site Network.
         */
        public int destSiteId;

        /** No-arg constructor. */
        public IsmIdentifier() {
            this.sourceSiteId = InterSiteMessage.RECIPROCAL_NET_COORDINATOR;
            this.sourceSeqNum = 0;
            this.destSiteId = InterSiteMessage.ALL_SITES;
        }

        /** Constructor that completely populates this object from arguments. */
        public IsmIdentifier(int sourceSiteId, long sourceSeqNum,
                int destSiteId) {
            this.sourceSiteId = sourceSiteId;
            this.sourceSeqNum = sourceSeqNum;
            this.destSiteId = destSiteId;
        }

        /**
         * Constructs an identifier to represent the specified
         * {@code InterSiteMessage}.
         */
        public IsmIdentifier(InterSiteMessage ism) {
            this.sourceSiteId = ism.sourceSiteId;
            this.sourceSeqNum = ism.sourceSeqNum;
            this.destSiteId = ism.destSiteId;
        }

        /**
         * Constructs an identifier based upon the contents of the current row
         * of the supplied database {@code ResultSet} object.
         */
        public IsmIdentifier(ResultSet rs) throws SQLException {
            this.sourceSiteId = rs.getInt("sourceSiteId");
            this.sourceSeqNum = rs.getLong("sourceSeqNum");
            this.destSiteId = rs.getInt("destSiteId");
        }

        /**
         * @return true if the corresponding message was received by the local
         *         site after having been originated by some other site.
         *         Presumably in this case the corresponding stored message file
         *         would be found in the received messages directory.
         * @param localSiteId identifies the local site.
         */
        public boolean isReceivedMessage(int localSiteId) {
            return this.sourceSiteId != localSiteId;
        }

        /**
         * @return true if the corresponding message was originated by the local
         *         site. Presumably in this case the corresponding stored
         *         message file would be found in the sent messages directory.
         * @param localSiteId identifies the local site.
         */
        public boolean isSentMessage(int localSiteId) {
            return this.sourceSiteId == localSiteId;
        }

        /**
         * @return an appropriate name for the corresponding stored message file
         *         identified by this object.
         */
        public String getSuggestedFileName() {
            return InterSiteMessage.getSuggestedFileName(this.sourceSiteId,
                    this.sourceSeqNum);
        }

        /**
         * Writes this object's contents to the current row of the supplied
         * database {@code ResultSet} object.
         */
        public void dbStore(ResultSet rs) throws SQLException {
            rs.updateInt("sourceSiteId", this.sourceSiteId);
            rs.updateLong("sourceSeqNum", this.sourceSeqNum);
            if (this.destSiteId != InterSiteMessage.ALL_SITES) {
                rs.updateInt("destSiteId", this.destSiteId);
            } else {
                rs.updateNull("destSiteId");
            }
        }
    }
}
