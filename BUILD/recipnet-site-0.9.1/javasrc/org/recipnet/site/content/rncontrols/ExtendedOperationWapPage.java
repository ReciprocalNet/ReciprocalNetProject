/*
 * Reciprocal Net project
 * 
 * ExtendedOperationWapPage.java
 *
 * 27-Jan-2005: midurbin wrote first draft
 * 05-Jul-2005: midurbin replaced calls to addFormContent() with calls to
 *              addFormField()
 * 07-Jul-2005: midurbin updated performWorkflowAction() to return a boolean
 *              and to only close the persisted operation if the superclass'
 *              method returned true
 * 11-Jul-2005: ekoperda refactored code and added function
 *              createPersistedOperation() to better support subclasses
 * 27-Jul-2005: midurbin moved code to close the PersistedOperation to abort(),
 *              removing performWorkflowAction() and cancelWorkflowAction() and
 *              updated doAfterBody(), doBeforeBody() to reflect name and
 *              spec changes
 * 04-Aug-2005: removed called to closePersistedOp() from abort() and added it
 *              to cancelWorkflowAction()
 * 08-Mar-2006: jobollin formatted the source and removed unused imports, and
 *              fixed bug #1745 in getSampleInfo()
 * 03-Nov-2006: jobollin ensured that the persisted operation is closed after
 *              the workflow action is either performed or canceled.
 */

package org.recipnet.site.content.rncontrols;

import java.io.IOException;
import java.rmi.RemoteException;

import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.JspException;

import org.recipnet.common.controls.EvaluationAbortedException;
import org.recipnet.common.controls.HtmlPage;
import org.recipnet.site.core.ResourceNotFoundException;
import org.recipnet.site.shared.db.SampleInfo;
import org.recipnet.site.wrapper.OperationPersister;
import org.recipnet.site.wrapper.PersistedOperation;
import org.recipnet.site.wrapper.WorkflowActionPersistedOperation;

/**
 * An extension of {@code WapPage} that allows a page to have fields modified
 * over multiple round trips but only have one workflow action performed.  This
 * tag exposes the method {@code queueSampleChanges()} to specialized tags. When
 * invoked, this method checks to ensure that no validation errors have been
 * reported and then stores the {@code SampleInfo} in a
 * {@code WorkflowActionPersistedOperation} and reloads the page, supplying the
 * id of the {@code PersistedOperation} as the 'persistedOpId' URL paramter.
 * When the page loads, it uses the stored {@code SampleInfo} and allows more
 * modifications until finally {@code WapPage.triggerWorkflowAction()} or
 * {@code WapPage.cancelWorkflowAction()} is invoked.
 */
public class ExtendedOperationWapPage extends WapPage {

    /**
     * A {@code WorkflowActionPersistedOperation} that maintians a
     * {@code SampleInfo} object that may be modified on multiple roundtrips to
     * this page. The method {@code doBeforePageBody()} may set this variable to
     * a previously created operation or {@code persistSampleChanges()} may
     * initialize this object. This object is initialized to null by
     * {@code reset()} and when non-null will supply the return value for
     * {@code getSampleInfo()}.
     */
    private WorkflowActionPersistedOperation persistedOp;

    /**
     * An internal variable that indicates whether to save these sample changes
     * to a {@code WorkflowActionPersistedOperation} and reevaluate the page
     * using the new sample at the end of the {@code PROCESSING_PHASE}.
     */
    private boolean queueSampleChanges;

    /**
     * A reference to the web application's {@code OperationPersister} object,
     * set during {@code REGISTRATION_PHASE}.
     */
    private OperationPersister operationPersister;

    /**
     * Overrides {@code HtmlPage} to initialize all member variables. Subclasses
     * may override this method, but MUST delegate back to their superclass.
     */
    @Override
    protected void reset() {
        super.reset();
        this.persistedOp = null;
        this.queueSampleChanges = false;
        this.operationPersister = null;
    }

    /**
     * Overrides {@code WapPage}; the current implementation attempts to set
     * {@code persistedOp} using the id in the "persistedOpId" URL parameter if
     * it is present during the {@code FETCHING_PHASE}. This method first
     * delegates back to the superclass.
     * 
     * @throws IllegalArgumentException if the URL parameter "persistedOpId"
     *         does not reference a {@code PersistedOperation} or references one
     *         that was not generated by the currently logged in user.
     * @throws JspException wrapping {@code IOException}s that may have been
     *         thrown
     */
    @Override
    protected void doBeforePageBody() throws JspException,
            EvaluationAbortedException {
        super.doBeforePageBody();
        switch (getPhase()) {
            case HtmlPage.REGISTRATION_PHASE:
                this.operationPersister = OperationPersister.extract(
                        this.pageContext.getServletContext());
                break;

            case HtmlPage.FETCHING_PHASE:
                try {
                    // Parse a persistedOperationId that the browser might have
                    // preserved from a previous POST or GET. This logic needs
                    // to happen on FETCHING_PHASE because we sometimes pass
                    // persistedOperationId's on the query line.
                    String opIdStr = this.pageContext.getRequest().getParameter(
                            "persistedOpId");
                    int persistedOperationId
                            = PersistedOperation.ID_NOT_ASSIGNED;
                    if (opIdStr != null) {
                        try {
                            persistedOperationId = Integer.parseInt(opIdStr);
                        } catch (NumberFormatException ex) {
                            // the URL contained a non-number for the persisted
                            // operation id
                            try {
                                ((HttpServletResponse)
                                        super.pageContext.getResponse()).sendError(
                                                HttpServletResponse.SC_BAD_REQUEST);
                                abort();
                                return;
                            } catch (IOException ioe) {
                                throw new JspException(ioe);
                            }
                        }
                    }

                    if (persistedOperationId
                            == PersistedOperation.ID_NOT_ASSIGNED) {
                        // Generate a new persisted operation, with a new id,
                        // because none exists yet
                        this.persistedOp = createPersistedOperation();
                        persistedOperationId
                                = this.operationPersister.registerOperation(
                                        persistedOp);
                    } else {
                        // Fetch the existing UploaderOperation from the
                        // OperationPersister. The call below throws an
                        // exception if the id number is invalid.
                        this.persistedOp = (WorkflowActionPersistedOperation)
                                this.operationPersister.getOperation(
                                        persistedOperationId);
                        if (this.persistedOp.getUserId() != getUserInfo().id) {
                            // The current user doesn't have access to this
                            // persisted operation
                            throw new IllegalArgumentException();
                        }
                    }
                } catch (IOException ex) {
                    throw new JspException(ex);
                } catch (ResourceNotFoundException ex) {
                    throw new JspException(ex);
                }
                
                // If we get here then we must have found or created persistedOp
                assert (this.persistedOp != null);
                
                break;

            case HtmlPage.RENDERING_PHASE:
                if (this.persistedOp != null) {
                    this.addFormField("persistedOpId",
                            String.valueOf(this.persistedOp.getId()));
                }
                break;
        }
    }

    /**
     * Overrides {@code WapPage}; during the {@code PROCESSING_PHASE}, the
     * current implementation checks to see whether {@code queueSampleChanges()}
     * has been called, and if so invokes {@code persistSampleChanges()} before
     * delegating back to the superclass.
     */
    @Override
    protected void doAfterPageBody() throws JspException,
            EvaluationAbortedException {
        switch (getPhase()) {
            case HtmlPage.PROCESSING_PHASE:
                if (this.queueSampleChanges) {
                    persistSampleChanges();
                }
                break;
        }
        super.doAfterPageBody();
    }

    /**
     * Overrides {@code WapPage}; the current implementation sets the comments
     * on a {@code WorkflowActionPersistedOperation} in the event that one is
     * open. Otherwise, it delegates to the superclass' implementation.
     */
    @Override
    public void setComments(String comments) {
        if (this.persistedOp != null) {
            this.persistedOp.setComments(comments);
        } else {
            super.setComments(comments);
        }
    }

    /**
     * Overrides {@code WapPage}; the current implementation gets the comments
     * from a {@code WorkflowActionPersistedOperation} in the event that one is
     * open. Otherwise, it delegates to the superclass' implemenation.
     */
    @Override
    public String getComments() {
        if (this.persistedOp != null) {
            return this.persistedOp.getComments();
        } else {
            return super.getComments();
        }
    }

    /**
     * Overrides {@code SamplePage}; the current implementation gets the sample
     * from a {@code WorkflowActionPersistedOperation} in the event that one is
     * open. Otherwise, it delegates to the superclass' implementation. This
     * method should not be called before the {@code FETCHING_PHASE}.
     */
    @Override
    public SampleInfo getSampleInfo() {
        if (this.persistedOp != null) {
            return this.persistedOp.getSampleInfo();
        } else {
            
            /*
             * A persistedOp is always either looked up or created during the
             * fetching phase before body evaluation, so this branch should only
             * be followed until that occurs.  An actual assertion of that
             * condition is dificult to write, however, because the superclass
             * invokes this method during the fetching phase in its
             * doBeforePageBody() method (indirectly via checkAuthorization()).
             */
            
            return super.getSampleInfo();
        }
    }

    /**
     * Triggers the storage of the sample modifications on the page in a
     * {@code WorkflowActionPersistedOperation} so that more changes may be made
     * in subsequent HTTP roundtrips. Specifically this method causes
     * {@code persistSampleChanges()} to be called at the end of the
     * {@code PROCESSING_PHASE}. Unlike {@code triggerWorkflowAction()} no
     * changes are made to the actual sample as a result of this call.
     * 
     * @throws IllegalStateException if called during the
     *         {@code RENDERING_PHASE} because it is too late to store the
     *         sample changes and redirect the browser
     */
    public void queueSampleChanges() {
        this.queueSampleChanges = true;
    }

    /**
     * Checks whether all the fields are valid, and if so, ensures that the
     * modified {@code SampleInfo} is stored in a
     * {@code WorkflowActionPersistedOperation} and triggers page reevaluation
     * so that more changes may be made. This method should be invoked at the
     * end of the {@code PROCESSING_PHASE} when {@code queueSampleChanges()} has
     * been called.
     * 
     * @throws JspException wrapping a {@code RemoteException} if one is thrown
     *         while creating a new {@code PersistedOperation}
     */
    protected void persistSampleChanges() throws JspException {
        // check validation
        if (!this.areAllFieldsValid()) {
            setErrorFlag(NESTED_TAG_REPORTED_VALIDATION_ERROR);
        }
    }

    /**
     * Overrides {@code HtmlPage}; the current implementation unsets
     * 'queueSampleChanges' then delegates back to the superclass.
     */
    @Override
    protected void onReevaluation() {
        this.queueSampleChanges = false;
        super.onReevaluation();
    }

    /**
     * A helper method that closes the persisted operation if it is not null,
     * otherwise it does nothing. This should be called after the workflow
     * action is performed or cancelled.
     * 
     * @throws JspException wrapping a {@code RemoteException} if one occurs
     */
    protected void closePersistedOp() throws JspException {
        if (this.persistedOp != null) {
            OperationPersister persister = OperationPersister.extract(
                    this.pageContext.getServletContext());
            try {
                persister.closeOperation(this.persistedOp.getId());
            } catch (IOException ex) {
                throw new JspException(ex);
            }
            persistedOp = null;
        }
    }

    /**
     * A helper method that constructs a new
     * {@code WorkflowActionPersistedOperation} when one is required. (A new
     * persisted op is created for every pageview for which the user does not
     * already have an assigned persisted op id.) Subclasses may override this
     * function to return a more specific type of persisted operation class.
     * This function normally is invoked during FETCHING_PHASE.
     */
    protected WorkflowActionPersistedOperation createPersistedOperation() {
        long timeoutInSeconds
                = this.pageContext.getSession().getMaxInactiveInterval();
        return new WorkflowActionPersistedOperation(
                ((timeoutInSeconds < 0) ? PersistedOperation.NO_TIME
                        : (timeoutInSeconds * 1000)),
                getSampleInfo(), getComments(), getUserInfo().id);
    }

    /**
     * Subclasses may call this method to obtain the current persisted operation
     * object. The function will return null if there is not one presently.
     */
    protected WorkflowActionPersistedOperation getPersistedOperation() {
        return this.persistedOp;
    }

    /**
     * {@inheritDoc}; this version ensures that the persisted operation is
     * closed after the superclass' version terminates.  Subclasses that
     * delegate to this implementation do not need to close it again.
     *
     * @see WapPage#performWorkflowAction()
     */
    @Override
    protected boolean performWorkflowAction() throws JspException,
            EvaluationAbortedException {
        try {
            return super.performWorkflowAction();
        } finally {
            // The persisted operation must be closed every time
            closePersistedOp();
        }
    }

    /**
     * {@inheritDoc}; this version ensures that the persisted operation is
     * closed after the superclass' version terminates.  Subclasses that
     * delegate to this implementation do not need to close it again.
     *
     * @see WapPage#cancelWorkflowAction()
     */
    @Override
    protected void cancelWorkflowAction() throws JspException,
            EvaluationAbortedException {
        try {
            super.cancelWorkflowAction();
        } finally {
            // The persisted operation must be closed every time
            closePersistedOp();
        }
    }
}
