<!doctype html public "-//w3c//dtd html 4.0 transitional//en"><html><head>   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">   <meta name="GENERATOR" content="Mozilla/4.78 [en] (Windows NT 5.0; U) [Netscape]">   <title>Developer Notes</title><!--   $Id :$--></head><body text="#000000" bgcolor="#FFFFFF" link="#0000FF" vlink="#660066" alink="#FF0000"><center><h2><font color="#000099">Getting Started with JAXM</font><font color="#3333FF">&nbsp;</font><img SRC="xml-pic.jpg" height=120 width=100></h2></center>This document outlines the steps needed to write applications that usethe JAXM API. &nbsp;<h2>Creating and Sending Messages Using a Messaging Provider</h2>Here are the steps to get started with developing applications using JAXM<u>witha messaging provider.</u><p>When a messaging provider is used, all messages go through it. Thismeans that when a client sends a message, the message goes to the messagingprovider and is then forwarded to the recipient. When the client is therecipient of a message, the messaging provider gets the message and forwardsit to the client. For this reason, the client's connection is with themessaging provider.<p>Note that in order to get a JAXM application that uses a messaging providerrunning, you'll have to refer to the "<a href="config.html">Deploymentand Configuration Guide</a>" for details about configuring the client andthe messaging provider.<ol><li><u>Creating a Connection</u></li><p>To get started with developing applications using JAXM with a messagingprovider, you need to create a <tt>ProviderConnection</tt> object thatrepresents the client's active connection to its messaging provider. Tocreate this connection, you first need to obtain an instance of the <tt><a href="api/javax/xml/messaging/ProviderConnectionFactory.html">ProviderConnectionFactory</a></tt>class that creates connections to the desired messaging provider. If themessaging provider has registered an instance of its connection factorywith a naming service based on Java<sup><font size=-2>TM</font></sup> Namingand Directory Interface (JNDI) technology, you can do a lookup of the<tt>ProviderConnectionFactory</tt>object that you want. Once you have an instance of the appropriate connectionsfactory, you can use it to create a connection to your messaging provider.<p>The following code sample shows how to create a <a href="api/javax/xml/messaging/ProviderConnection.html">ProviderConnection</a>object. The argument provided to the <tt>lookup</tt> method is the URIassociated with the desired messaging provider.<p>The first two lines in this example use JNDI API to create a context,which is then used to do the lookup. The <tt>lookup</tt> method returnsan <tt>Object</tt>, so the result of the lookup has to be cast to a<tt>ProviderConnectionFactory</tt>object.<pre>&nbsp;&nbsp;&nbsp; Context ctx = new InitialContext();&nbsp;&nbsp;&nbsp; ProviderConnectionFactory pcf = (ProviderConnectionFactory)ctx.lookup(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; providerURI);&nbsp;&nbsp;&nbsp; ProviderConnection pc = pcf.createConnection();</pre>It is also possible to get a <tt>ProviderConnectionFactory</tt> objectwithout doing a JNDI lookup. You can simply use the <tt>ProviderConnectionFactory</tt>method <tt>newInstance</tt>, which will create a connection to the defaultprovider implementation.<pre>&nbsp;&nbsp;&nbsp; ProviderConnectionFactory pcf = ProviderConnectionFactory.newInstance();&nbsp;&nbsp;&nbsp; ProviderConnection con = pcf.createConnection();</pre><b>NOTE</b>: Because this release does not come with a JNDI provider, <tt>newInstance()</tt>is the recommended way to work with a messaging provider. Typically a JNDIprovider is part of a container (for example: Tomcat 4.x or J2EE); youwill have to use a container-specific mechanism to populate the JNDI namingcontext with an appropriate instance of the <tt>ProviderConnectionFactory</tt>.<br>&nbsp;<li><u>Creating a message factory</u></li><p>You use the connection to your messaging provider to create a <tt>MessageFactory</tt>object, which you can then use to create a message. If you specify a profilewhen you create a <tt>MessageFactory</tt> object, the message factory thatis returned will create instances of <tt>SOAPMessage</tt> subclasses thatare appropriate for the given profile.<p>The following code fragment uses the connection to the messaging providerto get metadata about the profiles that the provider supports. The profilethat matches the ebXML profile is passed as a <tt>String</tt> to the method<tt>createMessageFactory</tt>.<pre>&nbsp;&nbsp;&nbsp; ProviderMetaData metaData = pc.getMetaData();&nbsp;&nbsp;&nbsp; String[] supportedProfiles = metaData.getSupportedProfiles();&nbsp;&nbsp;&nbsp; String profile = null;&nbsp;&nbsp;&nbsp; for(int i=0; i &lt; supportedProfiles.length; i++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(supportedProfiles[i].equals("ebxml")) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; profile = supportedProfiles[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageFactory mf = pc.createMessageFactory(profile);</pre><li><u>Creating a message</u></li><p>With the <tt>MessageFactory</tt> object just created, you can createa <tt>SOAPMessage</tt> objectthat is appropriate to the minimal ebXML profile used in this RI.&nbsp;<!-- Need to change this. TBD. --><pre>&nbsp;&nbsp;&nbsp; EbXMLMessageImpl message = (EbXMLMessageImpl)mf.createMessage();&nbsp;&nbsp;&nbsp; message.setSender(new Endpoint(sender));&nbsp;&nbsp;&nbsp; message.setReceiver(new Endpoint(receiver));</pre><li><u>Populating the message</u><p>This is the same as populating a message without a messaging provider. Please refer to SAAJ documentation for this.</li><li><u>Sending the message on the connection</u></li><p>Now that the message has been created and the various parts filled,the message is ready to be sent. In the following code sample, the messageis sent asynchronously using the <tt>ProviderConnection</tt> method<a href="api/javax/xml/messaging/ProviderConnection.html#send()">send</a>.This method returns immediately after handing the message over to the messagingprovider.<pre>&nbsp;&nbsp;&nbsp; pc.send(message);</pre><li><u>Closing the connection</u></li><p>You use the <tt>ProviderConnection</tt> method<a href="api/javax/xml/messaging/ProviderConnection.html#close()">close</a>to close the <tt>ProviderConnection</tt> object when it is no longer needed.<pre>&nbsp;&nbsp;&nbsp; pc.close();</pre></ol><b>Note:</b> <u>On the client side</u><p>When a message is received on the client side, it is up to the applicationto process the message. The processing is determined by the<a href="api/javax/xml/messaging/JAXMServlet.html">JAXMServlet</a>object that has been registered for the endpoint at deployment time becauseit has the implementation of the method <tt>onMessage</tt>. When the messagingprovider gets a message, it calls the <tt>onMessage</tt> method of <a href="api/javax/xml/messaging/ReqRespListener.html">ReqRespListener</a>or<a href="api/javax/xml/messaging/OnewayListener.html">OnewayListener</a>,passing it the <tt>SOAPMessage</tt> object. The implementation of the<tt>onMessage</tt>method determines how the message is processed.</p></body></html>