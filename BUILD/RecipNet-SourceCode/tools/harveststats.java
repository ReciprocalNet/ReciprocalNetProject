/*
 * Reciprocal Net project
 * @(#)harveststats.java
 * 
 * 07-May-2004: midurbin wrote the first draft
 *
 */

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.text.ParseException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.recipnet.site.OperationFailedException;
import org.recipnet.site.core.msg.InterSiteMessage;
import org.recipnet.site.core.msg.SiteStatisticsISM;
import org.recipnet.site.shared.db.LabInfo;
import org.xml.sax.SAXException;

/**
 * A tool that allows the coordinator to easily harvest and analyze statistics
 * information from <code>SiteStatisticsISM</code>s that arrived in response to
 * a coordinators request.
 */
public class harveststats {

    /**
     * A <code>Map</code> mapping siteId's (<code>Integer</code>) to
     * <code>List</code>s of <code>DataPoint</code>s.
     */
    public static Map siteDataPointMap = new HashMap();

    /**
     * A <code>Map</code> mapping a <code>String</code> generated by the
     * concatination of the siteId and labId for a particular
     * <code>DataPoint</code> to a <code>List</code> of just such
     * <code>DataPoint</code> objects.
     */
    public static Map labDataPointMap = new HashMap();

    public static void main(String args[]) {

        boolean printSiteHeader = true;
        boolean printLabHeader = true;

        // default time frame is the past 30 days
        Date earliestDate = new Date(System.currentTimeMillis()
                - ((long) 2592000 * (long) 1000));
        Date latestDate = new Date(System.currentTimeMillis());

        // keeps track of how many arguments have been parsed
        int argsParsed = 0;

        if (args.length == 0) {
            System.out.println("Reciprocal Net Project");
            System.out.println();
            System.out.println("Usage: harveststats -fu [msgs-rcvd dir]"
                    + " [msgs-sent dir] [other dir] ...");
            System.out.println("        -f [date] indicates the earliest"
                    + " date from which to include stats"
                    + " (default: 30 days ago)");
            System.out.println("        -u [date] indicates the latest date"
                    + " from which to include stats (default: today)");
            return;
        } else {
            DateFormat dateFormat = DateFormat.getDateInstance();
            dateFormat.setLenient(true);
            if (args[0].indexOf("-") == 0) {
                argsParsed = 1;
                try {
                    if (args[0].indexOf("f") != -1) {
                        earliestDate = dateFormat.parse(args[argsParsed]);
                        argsParsed ++;
                    }
                    if (args[0].indexOf("u") != -1) {
                        latestDate = dateFormat.parse(args[argsParsed]);
                        argsParsed ++;
                    }
                } catch (ParseException ex) {
                    System.err.println("Cannot parse \"" + args[argsParsed]
                            + "\" as a date!");
                    return;
                }
            }
        }

        for (int i = argsParsed; i < args.length; i ++) {
            // for each directory specified as a command line argument..
            File[] files = new File(args[i]).listFiles();
            if (files == null) {
                System.err.println(args[i] + " is not a directory!");
                return;
            }
            for (int j = 0; j < files.length; j ++) {
                // ... try to parse the file as an XML document...
                try {
                    String xmlDoc = readStringFromFile(files[j]);
                    InterSiteMessage ism = InterSiteMessage.fromXml(xmlDoc);
                    if (ism instanceof SiteStatisticsISM) {
                        // .. if it's a SiteStatisticsISM...
                        SiteStatisticsISM siteStatsISM
                            = (SiteStatisticsISM) ism;
                        if (siteStatsISM.lastReset.getTime()
                                >= earliestDate.getTime()
                              && (ism.sourceDate.getTime()
                                <= latestDate.getTime())) {
                            // ... and it is within the indicated timeframe
                            //          record the datapoints.
                            List siteList = (List) siteDataPointMap.get(
                                    new Integer(ism.sourceSiteId));
                            if (siteList == null) {
                                siteList = new ArrayList();
                                siteDataPointMap.put(
                                        new Integer(ism.sourceSiteId),
                                        siteList);
                            }
                            addDataPoint(siteList,
                                    new DataPoint(LabInfo.INVALID_LAB_ID,
                                            siteStatsISM));
                            Iterator it
                               = siteStatsISM.labSpecificStatistics.iterator();
                            while (it.hasNext()) {
                                int labId = ((SiteStatisticsISM.PerLabStats)
                                        it.next()).labId;
                                List siteLabList
                                        = (List) labDataPointMap.get(
                                            new String(ism.sourceSiteId + ":"
                                                    + labId));
                                if (siteLabList == null) {
                                    siteLabList = new ArrayList();
                                    labDataPointMap.put(
                                            new String(ism.sourceSiteId + ":"
                                                    + labId), siteLabList);
                                }
                                addDataPoint(siteLabList, new DataPoint(labId, 
                                        (SiteStatisticsISM) ism));
                            }
                        } else {
                            System.err.println("Skipping \"" + files[j]
                                    + "\" because it includes data that does"
                                    + " not fall within the designated"
                                    + " period.");

                        }
                    }
                } catch (IOException ex) {
                    System.err.println("Error reading file \""
                            + files[j].getName() + "\"!");
                    ex.printStackTrace(System.err);
                    return;
                } catch (SAXException ex) {
                    System.err.println("Error parsing file \""
                            + files[j].getName() + "\"!");
                    ex.printStackTrace(System.err);
                    return;
                } catch (OperationFailedException ex) {
                    System.err.println("Error parsing file \""
                            + files[j].getName() + "\"!");
                    ex.printStackTrace(System.err);
                }
            } 
        }

        // create a PrintStream on which to write the comma-delimited output
        PrintStream ps = null;
        File siteFile = new File("site.txt");
        if (siteFile.exists()) {
            System.err.println("\"" + siteFile + "\" already exists,"
                    + " dumping output to screen...");
            ps = new PrintStream(System.out);
        } else {
            try {
                ps = new PrintStream(new FileOutputStream(siteFile));
            } catch (Exception ex) {
                ex.printStackTrace(System.err);
                return;
            }
        }
        Collection siteEntrySet = siteDataPointMap.entrySet();
        Iterator it = siteEntrySet.iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            int siteId = ((Integer) entry.getKey()).intValue();
            long statisticsRecordingDuration = 0;
            String mostRecentVersion = null;
            int totalStartups = 0;
            int totalShutdowns = 0;
            int totalSecondsUptime = 0;
            int totalAuthWebappSessions = 0;
            int totalUnauthWebappSessions = 0;
            int totalOaiPmhQueries = 0;
            int totalOaiPmhQuerySamples = 0;
            Collections.sort((List) entry.getValue());
            Iterator it2 = ((Collection) entry.getValue()).iterator();
            while (it2.hasNext()) {
                DataPoint dp = (DataPoint) it2.next();
                statisticsRecordingDuration
                        += dp.siteStatsISM.sourceDate.getTime()
                                - dp.siteStatsISM.lastReset.getTime();
                totalStartups += dp.siteStatsISM.countRecipnetdStartups;
                totalShutdowns += dp.siteStatsISM.countRecipnetdShutdowns;
                totalSecondsUptime += dp.siteStatsISM.uptime;
                totalUnauthWebappSessions
                        += dp.siteStatsISM.authWebappSessions;
                totalUnauthWebappSessions
                        += dp.siteStatsISM.unauthWebappSessions;
                totalOaiPmhQueries += dp.siteStatsISM.countOaiPmhQueries;
                totalOaiPmhQuerySamples
                        += dp.siteStatsISM.countOaiPmhQuerySamples;
                if (!it2.hasNext()) {
                    // last entry in the sorted Collection, must be most recent
                    mostRecentVersion = dp.siteStatsISM.version;
                }
            }
            if (printSiteHeader) {
                ps.println("duration,coverage,siteId,version,startups,"
                        + "shutdowns,uptime,countAuthWebappSessions,"
                        + "countUnauthWebappSessions,OaiPmhQueries,"
                        +"OaiPmhQuerySamples");
                printSiteHeader = false;
            }
            ps.print(latestDate.getTime()
                    - earliestDate.getTime() + ",");
            ps.print((double) statisticsRecordingDuration
                    / (double) (latestDate.getTime()
                            - earliestDate.getTime()) + ",");
            ps.print(siteId + ",");
            ps.print(mostRecentVersion + ",");
            ps.print(totalStartups + ",");
            ps.print(totalShutdowns + ",");
            ps.print(totalSecondsUptime + ",");
            ps.print(totalAuthWebappSessions + ",");
            ps.print(totalUnauthWebappSessions + ",");
            ps.print(totalOaiPmhQueries + ",");
            ps.println(totalOaiPmhQuerySamples);
        }

        File labFile = new File("lab.txt");
        if (labFile.exists()) {
            System.err.println("\"" + labFile + "\" already exists,"
                    + " dumping output to screen...");
            ps = new PrintStream(System.out);
        } else {
            try {
                ps = new PrintStream(new FileOutputStream(labFile));
            } catch (Exception ex) {
                ex.printStackTrace(System.err);
                return;
            }
        }
        Collection labEntrySet = labDataPointMap.entrySet();
        it = labEntrySet.iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            String siteLabPair[] = ((String) entry.getKey()).split(":");
            int siteId = Integer.parseInt(siteLabPair[0]);
            int labId = Integer.parseInt(siteLabPair[1]);
            long statisticsRecordingDuration = 0;
            int totalShowSamplePageViews = 0;
            int totalEditSamplePageViews = 0;
            int mostRecentPublicSampleCount = 0;
            long mostRecentRepositorySize = 0;
            Collections.sort((List) entry.getValue());
            Iterator it2 = ((Collection) entry.getValue()).iterator();
            while (it2.hasNext()) {
                DataPoint dp = (DataPoint) it2.next();
                statisticsRecordingDuration
                        += dp.siteStatsISM.sourceDate.getTime()
                                - dp.siteStatsISM.lastReset.getTime();
                SiteStatisticsISM.PerLabStats labStats = dp.getLabStats();
                totalShowSamplePageViews += labStats.showSamplePageViews;
                totalEditSamplePageViews += labStats.editSamplePageViews;
                if (!it2.hasNext()) {
                    // last entry in the sroted Collection, must be most
                    // recent
                    mostRecentPublicSampleCount
                            = labStats.countPublicSamples;
                    mostRecentRepositorySize
                            = labStats.repositorySize;
                }
            }
            if (printLabHeader) {
                ps.println("duration,coverage,siteId,labId,showsample,"
                        + "editsample,publicSampleCount,repositorySize");
                printLabHeader = false;
            }
            ps.print(latestDate.getTime()
                    - earliestDate.getTime() + ",");
            ps.print((double) statisticsRecordingDuration
                    / (double) (latestDate.getTime()
                            - earliestDate.getTime()) + ",");
            ps.print(siteId + ",");
            ps.print(labId + ",");
            ps.print(totalShowSamplePageViews + ",");
            ps.print(totalEditSamplePageViews + ",");
            ps.print(mostRecentPublicSampleCount + ",");
            ps.println(mostRecentRepositorySize);
        }
    }

    /**
     * Helper function that reads the specified file into memory (in entirety)
     * and returns a String that contains the file's data (decoded using UTF-8
     * charset).  This method was copied from MessageFileAgent.
     */
    private static String readStringFromFile(File f) throws IOException {
	FileInputStream is = new FileInputStream(f);
	byte data[] = new byte[(int) f.length()];
	int bytesRead = 0;
	do {
	    bytesRead += is.read(data, bytesRead, data.length - bytesRead);
	} while (bytesRead < data.length);
	is.close();
	return new String(data, "UTF-8");
    }

    private static void addDataPoint(Collection dataPoints,
            DataPoint dataPoint) {
        // check for overlap with existing datapoints
        // two DataPoints overlap if they pertain to the same site and site and
        // cover any shared period of time.
        Iterator it = dataPoints.iterator();
        while (it.hasNext()) {
            DataPoint dp = (DataPoint) it.next();
            if (dataPoint.siteStatsISM.sourceDate.getTime()
                        > dp.siteStatsISM.lastReset.getTime()
                    || dataPoint.siteStatsISM.lastReset.getTime()
                        < dp.siteStatsISM.sourceDate.getTime()
                    || dataPoint.siteStatsISM.sourceSiteId
                        != dp.siteStatsISM.sourceSiteId
                    || dataPoint.labId != dp.labId) {
                // no possible overlap
            } else if (dataPoint.siteStatsISM.lastReset.getTime()
                        >= dp.siteStatsISM.lastReset.getTime()
                    || dataPoint.siteStatsISM.sourceDate.getTime()
                        <= dp.siteStatsISM.sourceDate.getTime()) {
                // dataPoint is completely overlapped by the current exisiting
                // datapoint and thus can be ignored
                return;
            } else if (dataPoint.siteStatsISM.lastReset.getTime()
                        <= dp.siteStatsISM.lastReset.getTime()
                    || dataPoint.siteStatsISM.sourceDate.getTime()
                        >= dp.siteStatsISM.sourceDate.getTime()) {
                // dataPoint is completely overlapping the current existing
                // record and thus the current record can be removed in favor
                // of this record
                it.remove();
            } else {
                throw new IllegalArgumentException();
                // unhandleable overlap
            }
        }
        dataPoints.add(dataPoint);
    }

    /**
     * Represents a range of statistics data collection for one particular
     * site, or one particular lab within a site.  A single
     * <code>SiteStatisticsISM</code> may be parsed into multiple
     * <code>DataPoitn</code> objects, one for the site-specific statistics and
     * one for each lab.  The current implemention wraps a reference to the
     * <code>SiteStatisticsISM</code> containing the raw data.
     */
    public static class DataPoint implements Comparable {

        /**
         * Indicates the lab about which this datapoint pertains, or if set to
         * <code>LabInfo.INVALID_LAB_ID</code>, indicates that this DataPoint
         * represents site-specific data.
         */
        public int labId;

        /**
         * The ISM containing the statistics information.  Note: more
         * information is held in this ISM than is relevent for this DataPoint.
         */
        public SiteStatisticsISM siteStatsISM;

        /** The basic constructor. */
        public DataPoint(int labId, SiteStatisticsISM ism) {
            this.labId = labId;
            this.siteStatsISM = ism;
        }

        /**
         * This method returns the appropriate <code>PerLabStats</code> object
         * for this <code>DataPoint</code>.  All lab-specific stats should be
         * taken from the object returned from this method.
         * @return the <code>PerLabStats</code> record from the
         * <code>SiteStatisticsISM</code> for this <code>DataPoint</code> or
         *  null if this <code>DataPoint</code> does not pertain to a lab.
         */
        public SiteStatisticsISM.PerLabStats getLabStats() {
            Iterator it = this.siteStatsISM.labSpecificStatistics.iterator();
            while (it.hasNext()) {
                SiteStatisticsISM.PerLabStats labStats
                        = (SiteStatisticsISM.PerLabStats) it.next();
                if (labStats.labId == this.labId) {
                    return labStats;
                }
            }
            return null;
        }

        /**
         * Facillitates sorting.  First SiteId is compared, then LabId, then
         * the sourceDate of the ISM and finally by the lastReset date.
         * @param o a <code>DataPoint</code> to which this
         *     <code>DataPont</code> will be compared.
         * @return a negative, zero or positive int depending on whether this
         *     object is less than, equal to, or greater than the passed object
         *     respectively.
         */
        public int compareTo(Object o) {
            assert LabInfo.INVALID_LAB_ID < 0;
            DataPoint rhs = (DataPoint) o;
            if (rhs.siteStatsISM.sourceSiteId
                // sort first by siteId...
                    != this.siteStatsISM.sourceSiteId) {
                return this.siteStatsISM.sourceSiteId
                        - rhs.siteStatsISM.sourceSiteId;
            } else if (rhs.labId != rhs.labId) {
                // ... then by labId (given that INVALID_LAB_ID == -1) ...
                return this.labId - rhs.labId;
            } else if (this.siteStatsISM.sourceDate.getTime()
                   != rhs.siteStatsISM.sourceDate.getTime()) {
                // ... then by end time...
                return (int) this.siteStatsISM.sourceDate.getTime()
                        - (int) rhs.siteStatsISM.sourceDate.getTime();
            } else {
                // ... then finally by start time.
                return (int) this.siteStatsISM.sourceDate.getTime()
                        - (int) rhs.siteStatsISM.sourceDate.getTime();
            }
        }
    }
}
