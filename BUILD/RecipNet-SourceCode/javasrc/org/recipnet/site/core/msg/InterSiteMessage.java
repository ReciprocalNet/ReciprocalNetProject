/*
 * Reciprocal Net project
 * 
 * InterSiteMessage.java
 *
 * 03-Jul-2002: ekoperda wrote first draft
 * 26-Sep-2002: ekoperda added support for serialization to/from XML and also
 *              moved the class into the core.msg package, from the container
 *              package
 * 08-Oct-2002: ekoperda added functions getSourceSiteIdFromFileName(),
 *              getSeqNumFromFileName(), compareTo() (interface Comparable),
 *              and equals().
 * 09-Oct-2002: ekoperda changed compareTo() so that these objects are now
 *              sorted by sourceSiteId and sourceSeqNum, but not sourceDate
 * 31-Oct-2002: ekoperda fixed bug #574 related to precision in prevSeqNum
 *              field
 * 21-Feb-2003: ekoperda added exception support to toXml(), 
 *              toXmlAddSignature(), fromXml(), and fromXmlCheckSignature()
 * 13-May-2003: midurbin fixed bug #817 in toXmlAddSignature(),
 *              fromXmlCheckSignature()
 * 07-Jan-2004: ekoperda changed package references to match source tree
 *              reorganization
 * 11-Feb-2005: midurbin fixed bug #1532 in insertIntoDom()
 * 15-Dec-2005: ekoperda added 'linkLocal' field, isPublic(), and isPrivate()
 * 21-Apr-2006: jobollin reformatted the source, removed unused imports,
 *              converted to generics, fixed minor bugs in compareTo() and
 *              equals(), overrode Object.hashCode() for consistency with
 *              equals()
 * 29-Dec-2007: ekoperda standardized XML document headers used by 
 *              toXmlAddSignature() and fromXmlCheckSignature()
 * 10-Jan-2008: ekoperda fixed bug #1884 in fromXmlCheckSignature()
 * 16-May-2008: ekoperda added isFromCoordinator()
 * 26-Nov-2008: ekoperda added isFrom() and isTo() for convenience
 */

package org.recipnet.site.core.msg;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.security.Signature;
import java.security.SignatureException;
import java.text.NumberFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.recipnet.site.OperationFailedException;
import org.recipnet.site.shared.DomTreeParticipant;
import org.recipnet.site.shared.DomUtil;
import org.recipnet.site.shared.SoapUtil;
import org.recipnet.site.shared.db.SiteInfo;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXParseException;

/**
 * <p>
 * Abstract base class for all messages that can be transmitted from one site
 * in the Site Network to another. Messages may be addressed to either all
 * sites, or to one site in particular. With the help of the DomUtil class,
 * messages may be transformed to and from XML format, appending and verifying
 * cryptographic digital signatures at the same time in order to ensure message
 * integrity. InterSiteMessage's all desend from the CoreMessage class, which
 * allows them to be delivered to each core module's message queue (which is in
 * turn serviced by each core module's worker thread).
 * </p><p>
 * Generally speaking, ISM's have the property that they can be
 * <i>replayed</i>.  That is, if a core module were to process a given ISM
 * once, and the corresponding database updates happened to be aborted in
 * mid-processing for some reason, then when the core module processed the
 * message a second time any dirty data that might have resulting from the
 * first operation would be overwritten (assuming no intervening database
 * operations had occurred). This property is crucial for guaranteeing
 * globally-consistent database state across the Reciprocal Net Site Network
 * </p><p>
 * In addition, any higher-level protocols built on top of ISM's must have the
 * following property: for two ISM's a and b, not necessarily originated at the
 * same site, where b was originated later in time than a, and both messages
 * are received by some site x, it must be the case that either: 1) the
 * aggregate changes to site x's database resulting from its acceptance and
 * processing of message a, followed by message b, are identical to the
 * database changes that would have resulted if message b had been processed,
 * followed by message a; or 2) if message b is processed before message a has
 * been processed, then the processing of message b will fail in such a way
 * that will cause message b to be re-processed (re-played) at some future
 * time.
 * </p>
 */
public abstract class InterSiteMessage extends CoreMessage implements
        Comparable<InterSiteMessage>, DomTreeParticipant, Serializable {
    /**
     * This string replicates the XML document header that appeared at the top
     * of every InterSiteMessage generated by release 0.5.2 of Reciprocal Net.
     * It is needed in order to properly verify ISM's that were generated by
     * earlier code.  
     */
    private static final String LEGACY_XML_DOCUMENT_HEADER = 
            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";

    public static final long INVALID_SEQ_NUM = -1;

    public static final int RECIPROCAL_NET_COORDINATOR = 0;

    public static final int ALL_SITES = -1;

    public static final String DATE_FORMAT = "yyyy-MM-dd kk:mm:ss Z";

    /**
     * Should be the site id for the site that originally sent this message.
     * The special value RECIPROCAL_NET_COORDINATOR is reserved for system
     * messages originated by the Reciprocal Net central governing authority.
     * (The governing authority does not operate a site and therefore cannot
     * receive messages.)
     */
    public int sourceSiteId;

    /**
     * The date at which this message was generated, as recorded by the
     * originating site.
     */
    public Date sourceDate;

    /**
     * The sequence number of this message. Sequence numbers are generated by
     * the message's originating site and must increase by 1 with every
     * message. The special value {@code INVALID_SEQ_NUM} is appropriate for
     * link-local messages.
     */
    public long sourceSeqNum;

    /**
     * The sequence number of the previous message that originated at this
     * source and had the same destSiteId value. This is used to guarantee
     * in-order delivery of messages. Should be INVALID_SEQ_NUM if no such
     * message exists.
     */
    public long sourcePrevSeqNum;

    /**
     * Indicates the site that should receive this message. If the message
     * should be delivered to all Reciprocal Net sites, this field should be
     * ALL_SITES.
     */
    public int destSiteId;

    /**
     * Set to true if the message should be delivered to Site Manager at the
     * destination site.
     */
    public boolean deliverToSiteManager;

    /**
     * Set to true if the message should be delvered to Sample Manager at the
     * destination site.
     */
    public boolean deliverToSampleManager;

    /**
     * Set to true if the message should be delivered to Repository Manager at
     * the destination site.
     */
    public boolean deliverToRepositoryManager;

    /**
     * Set to true if the message should be "delivered to file" at the
     * destination site; i.e. dumped to a file so that some external process
     * can pick it up later.
     */
    public boolean deliverToFile;

    /**
     * Set to true to indicate that this message requires link-local processing
     * an has no permanent significance. This necessarily implies that
     * {@code sourceSeqNum=INVALID_SEQ_NUM}.
     */
    public boolean linkLocal;

    /**
     * A cryptographic digital signature used to verify the message's
     * integrity.
     */
    public byte[] signature;

    /** default empty constructor */
    public InterSiteMessage() {
        this.sourceSiteId = SiteInfo.INVALID_SITE_ID;
        this.sourceDate = new Date();
        this.sourceSeqNum = INVALID_SEQ_NUM;
        this.sourcePrevSeqNum = INVALID_SEQ_NUM;
        this.destSiteId = SiteInfo.INVALID_SITE_ID;
        this.deliverToSiteManager = false;
        this.deliverToSampleManager = false;
        this.deliverToRepositoryManager = false;
        this.deliverToFile = false;
        this.linkLocal = false;
        this.signature = new byte[0];
    }

    /**
     * Returns a String representing the suggested name to be given to a
     * message file that contained only the specified message. The current
     * implementation names files by concatenating the 5-digit siteId of the
     * message's source with the 19-digit seqnum and adding the extension
     * '.xml'.
     */
    public static String getSuggestedFileName(int sourceSiteId,
            long sourceSeqNum) {
        String str;
        NumberFormat nf = NumberFormat.getInstance();
        
        nf.setMinimumIntegerDigits(5);
        nf.setMaximumIntegerDigits(5);
        nf.setGroupingUsed(false);
        str = nf.format(sourceSiteId);
        str += "-";
        nf.setMinimumIntegerDigits(19);
        nf.setMaximumIntegerDigits(19);
        str += nf.format(sourceSeqNum);
        str += ".xml";
        
        return str;
    }

    /**
     * Convenience function that invokes getSuggestedFileName() on this object.
     */
    public String getSuggestedFileName() {
        return getSuggestedFileName(sourceSiteId, sourceSeqNum);
    }

    /**
     * For the specified filename of an ISM that was named according to the
     * suggested naming convention, returns the corresponding sourceSeqNum
     * value. This function complements getSuggestedFileName().
     * 
     * @throws IllegalArgumentException if the filename is not in the expected
     *         format.
     */
    public static int getSourceSiteIdFromFileName(String filename) {
        String sourceSiteIdPart;
        int endpos = filename.indexOf("-");
        
        if (endpos < 0) {
            throw new IllegalArgumentException("Filename '" + filename
                    + "' does not object the ISM file naming convention");
        }
        
        sourceSiteIdPart = filename.substring(0, endpos);
        
        return Integer.parseInt(sourceSiteIdPart);
    }

    /**
     * For the specified filename of an ISM file that was named according to 
     * the suggested naming convention, returns the corresponding sourceSeqNum
     * value. This function complements getSuggestedFileName().
     * 
     * @throws IllegalArgumentException if the filename is not in the expected
     *         format.
     */
    public static long getSeqNumFromFileName(String filename) {
        int startpos = filename.indexOf("-") + 1;
        int endpos = filename.indexOf(".");
        String seqNumPart;
        
        if ((startpos < 0) || (endpos < 0)) {
            throw new IllegalArgumentException("Filename '" + filename
                    + "' does not obey the ISM file naming convention");
        }
        
        seqNumPart = filename.substring(startpos, endpos);
        
        return Long.parseLong(seqNumPart);
    }

    /**
     * Stores a representation of this object in the specified DOM tree,
     * perhaps during the process of this message being serialized to XML. From
     * interface DomTreeParticipant.
     * <p>
     * Subclasses should override this function to store their own
     * layer-specific data in the DOM tree. Every subclass implementation of
     * this function should first invoke super.insertIntoDom(doc, base), then
     * use the Node returned by that function as the base element for their own
     * layer-specific data in the DOM tree. Subclass implementations that have
     * no special provision for layer-specific data being stored by their own
     * subclasses should return the same Node that super.insertIntoDom()
     * returned.
     */
    public Node insertIntoDom(Document doc, Node base) {
        SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);

        // Create the root <message> element
        Element messageEl = DomUtil.createEl(doc, base, "message");
        
        DomUtil.addAttrToEl(messageEl, "source",
                ((this.sourceSiteId == RECIPROCAL_NET_COORDINATOR)
                        ? "coordinator"
                        : String.valueOf(this.sourceSiteId)));
        if (this.sourceSeqNum != INVALID_SEQ_NUM) {
            DomUtil.addAttrToEl(
                    messageEl, "seqnum", String.valueOf(this.sourceSeqNum));
        }
        if (this.linkLocal) {
            DomUtil.addAttrToEl(messageEl, "linkLocal", String.valueOf(true));
        }

        // Add all the child elements
        DomUtil.createTextEl(messageEl, "date", sdf.format(this.sourceDate));
        DomUtil.createTextEl(messageEl, "dest",
                ((this.destSiteId == ALL_SITES)
                        ? "all"
                        : String.valueOf(this.destSiteId)));
        if (this.sourcePrevSeqNum == INVALID_SEQ_NUM) {
            DomUtil.createEl(doc, messageEl, "prevseqnum");
        } else {
            DomUtil.createTextEl(messageEl, "prevseqnum",
                    String.valueOf(this.sourcePrevSeqNum));
        }
        
        Element bodyEl = DomUtil.createEl(doc, messageEl, "body");
        
        DomUtil.addAttrToEl(bodyEl, "class", getClassName());
        if (this.deliverToSiteManager) {
            DomUtil.createEl(doc, messageEl, "deliverToSiteManager");
        }
        if (this.deliverToSampleManager) {
            DomUtil.createEl(doc, messageEl, "deliverToSampleManager");
        }
        if (this.deliverToRepositoryManager) {
            DomUtil.createEl(doc, messageEl, "deliverToRepositoryManager");
        }
        if (this.deliverToFile) {
            DomUtil.createEl(doc, messageEl, "deliverToFile");
        }

        // Pass the bodyEl back to subclasses so that they may insert their
        // own data under it.
        return bodyEl;
    }

    /**
     * <p>
     * Fills this object's member variables with a previously-stored
     * representation of the object fetched from the specified DOM tree,
     * perhaps during the process of this message being un-serialized from XML.
     * From interface DomTreeParticipant.
     * </p><p>
     * Subclasses should override this function to retrieve their own layer-
     * specific data from the DOM tree. Every subclass implementation of this
     * function should first invoke super.extractFromDom(doc, base), then use
     * the Node returned by that function as the base element for their own
     * layer-specific data in the DOM tree. Subclass implementations that have
     * no special provision for layer-specific data being stored by their own
     * subclasses should return the same Node that super.extractFromDom()
     * returned.
     * </p>
     * 
     * @throws SAXException if the object's reprentation in the DOM tree is not
     *         valid or could not be processed.
     */
    public Node extractFromDom(@SuppressWarnings("unused") Document doc,
            Node base) throws SAXException {
        SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);

        // Get the <message> element and its attributes
        DomUtil.assertNodeName(base, "message");
        DomUtil.assertAttributeCount(base, 2);
        Element messageEl = (Element) base;
        this.sourceSiteId = DomUtil.getAttrForEl(
                messageEl, "source", true).equals(
                "coordinator") ? RECIPROCAL_NET_COORDINATOR
                : DomUtil.getAttrForElAsInt(messageEl, "source");
        this.sourceSeqNum = DomUtil.getAttrForElAsLong(messageEl, "seqnum",
                INVALID_SEQ_NUM);
        this.linkLocal = DomUtil.getAttrForElAsBoolean(messageEl, "linkLocal",
                false);

        // Get all the child elements
        try {
            this.sourceDate = sdf.parse(DomUtil.getTextForEl(messageEl, "date",
                    true));
        } catch (ParseException ex) {
            throw new SAXParseException("Invalid date format", null, ex);
        }
        this.destSiteId = DomUtil.getTextForEl(messageEl, "dest", true).equals(
                "all") ? ALL_SITES : DomUtil.getTextForElAsInt(messageEl,
                "dest");
        this.sourcePrevSeqNum = DomUtil.getTextForElAsLong(messageEl,
                "prevseqnum", INVALID_SEQ_NUM);
        Element bodyEl = DomUtil.findSingleElement(messageEl, "body", true);
        this.deliverToSiteManager = DomUtil.isElPresent(messageEl,
                "deliverToSiteManager");
        this.deliverToSampleManager = DomUtil.isElPresent(messageEl,
                "deliverToSampleManager");
        this.deliverToRepositoryManager = DomUtil.isElPresent(messageEl,
                "deliverToRepositoryManager");
        this.deliverToFile = DomUtil.isElPresent(messageEl, "deliverToFile");

        // Make sure the class name specified on the <body> element matches the
        // run-time type of this class.
        String bodyClassName = DomUtil.getAttrForEl(bodyEl, "class", true);
        if (!bodyClassName.equals(getClassName())) {
            throw new SAXException("Cannot extract an inter-site message of"
                    + " class '" + bodyClassName + "' into this object, which"
                    + " has type '" + getClassName() + "'");
        }

        // Pass the bodyEl back to subclasses so that they may extract their
        // own data from under it.
        return bodyEl;
    }

    /**
     * Uses this class's (and subclasses') implementations of 
     * DomTreeParticipant to generate an XML representation of the current
     * state of the object.
     * 
     * @throws IllegalStateException if the translation engines shared by all
     *         threads using this {@code DomUtil} failed to initialize
     *         for some reason.
     * @throws OperationFailedException if {@code DomUtil}'s
     *         transformation engine failed to execute the translation from DOM
     *         tree to XML.
     */
    public final String toXml() throws OperationFailedException {
        return DomUtil.objectToXml(this);
    }

    /**
     * Similar to toXml() above, except the XML representation returned
     * includes a digital signature that recipients of the string may use to
     * verify the string's authenticity. {@code sigEngine} should be a
     * Signature object that has been already been initialized by a call to
     * initSign() in which the message sender's private encryption key was
     * specified.
     * 
     * @throws IllegalStateException if the translation engines shared by all
     *         threads using this {@code DomUtil} failed to initialize
     *         for some reason.
     * @throws OperationFailedException if {@code DomUtil}'s
     *         transformation engine failed to execute the translation from DOM
     *         tree to XML.
     * @throws SignatureException if an error occurred while generating a
     *         signature on the XML.
     */
    public final String toXmlAddSignature(Signature sigEngine)
            throws OperationFailedException, SignatureException {
        // Build a DOM representation for this message
        Document doc = DomUtil.objectToDomTree(this);
        Element messageEl = doc.getDocumentElement();

	/*
	 * Transform the DOM tree into XML and compute the digital signature
	 * on it.  Take care to tightly control the XML document header.  The
	 * reason is that the digital signature covers the entire XML
	 * document, including the document header.  Thus, the header in-place
	 * when we sign the ISM must match the header that is reconstructed at
	 * the receiving end when the signature is verified.  This admittedly
	 * inelegant solution is necessary to maintain backwards compatibility
	 * with ISM's generated by earlier Reciprocal Net code.
	 */
	String xmlWithoutSignature = 
                LEGACY_XML_DOCUMENT_HEADER
	        + SoapUtil.dropXmlDocumentHeader(
                DomUtil.domTreeToXml(doc), "message");
        try {
            sigEngine.update(xmlWithoutSignature.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException ex) {
            // this should never happen
            throw new OperationFailedException(ex);
        }
        byte rawSignature[] = sigEngine.sign();

        // Insert a new <signature> element into the DOM tree
        Element sigEl = DomUtil.createTextElWithBinaryData(messageEl,
                "signature", rawSignature);
        DomUtil.addAttrToEl(sigEl, "algorithm", sigEngine.getAlgorithm());

        // Transform the new DOM tree (that includes a <signature> element)
        // into XML and return it.
        return DomUtil.domTreeToXml(doc);
    }

    /**
     * Uses this class's (and subclasses') implementations of
     * DomTreeParticipant to construct a new message from the provided XML
     * string (obtained via a previous call to toXml()). The exact type of
     * object returned is determined by the 'class' attribute of the &lt;body> 
     * element on the &lt;message> element, but is guaranteed to be a subclass
     * of InterSiteMessage.
     * 
     * @throws SAXException if the XML string is not a valid InterSiteMessage
     *     or could not be parsed.
     */
    public static final InterSiteMessage fromXml(String xmlMessage)
            throws SAXException {
        Document doc = DomUtil.xmlToDomTree(xmlMessage);
        
        return fromDomTree(doc, doc.getDocumentElement());
    }

    public static final InterSiteMessage fromDomTree(Document doc,
            Element messageEl) throws SAXException {
        InterSiteMessage ism;

        // Do a quick scan of the DOM tree to find the <body> element inside
        // the <message> element. The 'class' attribute on the <body> element
        // will tell us what kind of Java object we should instantiate.
        Element bodyEl = DomUtil.findSingleElement(messageEl, "body", true);
        String className = DomUtil.getAttrForEl(bodyEl, "class", true);
        String fullClassName = getPackageName() + "." + className;

        // Instantiate a new ISM of the appropriate type
        try {
            ism = (InterSiteMessage) Class.forName(
                    fullClassName).newInstance();
        } catch (LinkageError ex) {
            throw new SAXException("Message class '" + className
                    + "' could not be decoded due to a Linkage Error");
        } catch (ClassNotFoundException ex) {
            throw new SAXException("Message class '" + className
                    + "' could not be decoded", ex);
        } catch (IllegalAccessException ex) {
            throw new SAXException("Message class '" + className
                    + "' could not be decoded", ex);
        } catch (InstantiationException ex) {
            throw new SAXException("Message class '" + className
                    + "' could not be decoded", ex);
        } catch (SecurityException ex) {
            throw new SAXException("Message class '" + className
                    + "' could not be decoded", ex);
        }

        // Tell the newly-created ISM to extract itself from the DOM tree. It
        // will perform complete validation.
        ism.extractFromDom(doc, messageEl);

        return ism;
    }

    /**
     * Similar to fromXml() above, except this function verifies the message's
     * authenticity first. Authenticity is verified by checking the digital
     * signature included within the XML message against the public encryption
     * key for the message's purported sender, as provided by the caller.
     * {@code sigEngine} should be a Signature object which has already
     * been initialized by calling initVerify() and specifying the message
     * sender's public encryption key. The caller may use the function
     * extractSourceSiteId() to detect the message's purported sender and look
     * up his public encryption key prior to calling this function.
     * 
     * @throws IllegalStateException if the translation engines shared by all
     *         threads using this {@code DomUtil} failed to initialize
     *         for some reason.
     * @throws OperationFailedException if {@code DomUtil}'s
     *         transformation engine failed to execute the translation from XML
     *         to DOM tree.
     * @throws SAXException if the XML string is not a valid InterSiteMessage
     *         or could not be parsed.
     * @throws SignatureException if the signature does not match the message
     *         contents.
     */
    public static final InterSiteMessage fromXmlCheckSignature(
            String xmlMessage, Signature sigEngine)
            throws OperationFailedException, SAXException, SignatureException {
        InterSiteMessage ism;
        Document doc = DomUtil.xmlToDomTree(xmlMessage);
        Element messageEl = doc.getDocumentElement();

        /*
         * Find the <signature> element inside the <message> element. Extract
         * the encoded digital signature, then remove the <signature> element
         * from the DOM tree. Check the signature algorithm to make sure it's
         * compatible with the local implementation.
         */
        Element signatureEl = DomUtil.findSingleElement(messageEl, "signature",
                true);
        String algorithm 
                = DomUtil.getAttrForEl(signatureEl, "algorithm", true);
        if (!algorithm.equals(sigEngine.getAlgorithm())) {
            throw new SAXNotSupportedException("Expected digital signature"
                    + " algorithm '" + sigEngine.getAlgorithm()
                    + "', but found '" + algorithm + "'");
        }
        byte[] rawSignature = DomUtil.getTextForElAsBytes(signatureEl);
        messageEl.removeChild(signatureEl);

        /*
	 * Reconstruct in memory the XML document as it would have existed at
	 * the sending site at the moment the ISM was signed.  This requires
	 * that we remove the <signature> block from the XML string.  
	 * Additionally, we take pains to control the XML document header used
	 * during signature verification in order to preserve backwards
	 * compatibility with ISM's generated by earlier Reciprocal Net code.
	 * This is because the digital signature covers the entire XML
	 * document, including the header, but there is no guarantee that the
	 * sender used the same XML transformer we're using now.  Unless the
	 * header on the XML document right now matches the one that was
	 * present when the ISM was generated, the signature won't match.
	 *
	 * Fellow developers: the section of code below is very finicky.  If
	 * you make a change in error, sites running your code will be unable
	 * to verify some ISM's generated by other code.  Oftentimes the bug
	 * does not materialize until full field deployment.  We, the
	 * development team, have made several errors here before.  Please,
	 * please, tread lightly!  -ekoperda
	 */
	int iMessageBegin = xmlMessage.indexOf("<message ");
	int iBodyBegin = xmlMessage.indexOf("<body ", iMessageBegin);
	int iBodyEnd = xmlMessage.lastIndexOf("</body>", iBodyBegin) + 7;
	int iSignatureBegin = xmlMessage.indexOf("<signature ", iBodyEnd);
	int iSignatureEnd 
                = xmlMessage.indexOf("</signature>",iSignatureBegin) + 12;
	if (iMessageBegin < 0 || iBodyBegin < 0 || iBodyEnd < 0 
                || iSignatureBegin < 0 || iSignatureEnd < 0) {
	    throw new SAXException("Unable to strip <signature> block");
	}
	StringBuilder xmlDocumentToVerify = new StringBuilder();
	xmlDocumentToVerify.append(LEGACY_XML_DOCUMENT_HEADER);
	xmlDocumentToVerify.append(
                xmlMessage.substring(iMessageBegin, iSignatureBegin));
	xmlDocumentToVerify.append(
	        xmlMessage.substring(iSignatureEnd, xmlMessage.length()));

	// Verify the signature; throw an exception if the message is forged.
        try {
	    sigEngine.update(xmlDocumentToVerify.toString().getBytes("UTF-8"));
        } catch (UnsupportedEncodingException ex) {
            // this should never happen
            throw new OperationFailedException(ex);
        }
        boolean isAuthentic = sigEngine.verify(rawSignature);
        if (!isAuthentic) {
            throw new SignatureException("Signature on message is not"
                    + " authentic");
        }

        // Do a quick scan of the DOM tree to find the <body> element inside
        // the <message> element. The 'class' attribute on the <body> element
        // will tell us what kind of Java object we should instantiate.
        Element bodyEl = DomUtil.findSingleElement(messageEl, "body", true);
        String className = DomUtil.getAttrForEl(bodyEl, "class", true);
        String fullClassName = getPackageName() + "." + className;

        // Instantiate a new ISM of the appropriate type
        try {
            ism = (InterSiteMessage)Class.forName(fullClassName).newInstance();
        } catch (LinkageError ex) {
            throw new SAXException("Message class '" + className
                    + "' could not be decoded due to a Linkage Error");
        } catch (ClassNotFoundException ex) {
            throw new SAXException("Message class '" + className
                    + "' could not be decoded", ex);
        } catch (IllegalAccessException ex) {
            throw new SAXException("Message class '" + className
                    + "' could not be decoded", ex);
        } catch (InstantiationException ex) {
            throw new SAXException("Message class '" + className
                    + "' could not be decoded", ex);
        } catch (SecurityException ex) {
            throw new SAXException("Message class '" + className
                    + "' could not be decoded", ex);
        }

        // Tell the newly-created ISM to extract itself from the DOM tree. It
        // will perform complete validation.
        ism.extractFromDom(doc, doc.getDocumentElement());

        return ism;
    }

    /**
     * Convenience function that partially parses the specified XML
     * representation of an InterSiteMessage and returns the message's
     * purported sourceSiteId, as recorded in the 'source' attribute of the
     * <message> element. This function is most useful when called prior to
     * fromXmlCheckSignature().
     * 
     * @throws SAXException if the XML string is not a valid InterSiteMessage
     *         or could not be parsed.
     */
    public static final int extractSourceSiteId(String xmlMessage)
            throws SAXException {
        Document doc = DomUtil.xmlToDomTree(xmlMessage);

        // Get the 'source' attribute off the root <message> element.
        Element messageEl = doc.getDocumentElement();
        
        return DomUtil.getAttrForEl(messageEl, "source", true).equals(
                "coordinator") ? RECIPROCAL_NET_COORDINATOR
                : DomUtil.getAttrForElAsInt(messageEl, "source");
    }

    /**
     * Internal function that returns the effective (sub)class name of this
     * object, omitting the package name.
     */
    protected final String getClassName() {
        Class<?> c = super.getClass();
        
        return c.getName().substring(c.getPackage().getName().length() + 1);
    }

    /**
     * Internal function that returns the Java package name used by all
     * InterSiteMessage's and subclasses.
     */
    protected static final String getPackageName() {
        return InterSiteMessage.class.getPackage().getName();
    }

    /**
     * Convenience function used by MessageFileAgent to get the destSiteId of
     * an ISM representation in an existing DOM tree. messageEl points to the
     * root <message> element of this ISM's representation.
     */
    public static final int extractDestSiteIdFromDom(Element messageEl)
            throws SAXException {
        // Get the <message> element
        DomUtil.assertNodeName(messageEl, "message");

        // Get the value of the <dest> element
        return DomUtil.getTextForEl(messageEl, "dest", true).equals("all") 
                ? ALL_SITES
                : DomUtil.getTextForElAsInt(messageEl, "dest");
    }

    /**
     * Convenience function used by MessageFileAgent to get the sourceSeqNum of
     * an ISM representation in an existing DOM tree. messageEl points to the
     * root <message> element of this ISM's representation.
     */
    public static final long extractSourceSeqNumFromDom(Element messageEl)
            throws SAXException {
        // Get the <message> element
        DomUtil.assertNodeName(messageEl, "message");
        DomUtil.assertAttributeCount(messageEl, 2);

        // Get the value of the 'seqnum' attribute from the <message> element
        return DomUtil.getAttrForElAsLong(messageEl, "seqnum");
    }

    /**
     * Implements a natural ordering for instances based on source site ID and
     * sequence number.  Users should not assume any particular correlation
     * between the order implemented by this method and the order of message
     * receipt at any site.
     * 
     * @return -1, 0, or 1, depending on whether this message is less than,
     *         equal to, or greater than the specified message according to
     *         this class's natural ordering
     */
    final public int compareTo(InterSiteMessage x) {
        if (this.sourceSiteId < x.sourceSiteId) {
            return -1;
        } else if (this.sourceSiteId > x.sourceSiteId) {
            return 1;
        } else {
            if (this.sourceSeqNum < x.sourceSeqNum) {
                return -1;
            } else if (this.sourceSeqNum > x.sourceSeqNum) {
                return 1;
            } else {
                return 0;
            }
        }
    }

    /**
     * Two ISM's are considered equal if their {@code sourceSiteId} and
     * {@code sourceSeqNum} fields contain identical values.
     */
    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        } else if (o instanceof InterSiteMessage) {
            InterSiteMessage x = (InterSiteMessage) o;
            
            return ((this.sourceSiteId == x.sourceSiteId)
                    && (this.sourceSeqNum == x.sourceSeqNum));
        } else {
            return false;
        }
    }
    
    /**
     * Returns a hash code for this message based on its source site ID and
     * source sequence number, so that this implementation is consistent with
     * equals().
     * 
     * @return the hash code
     */
    @Override
    public int hashCode() {
        return (sourceSiteId ^ (int) (sourceSeqNum << 16));
    }

    /**
     * @return true if this ISM was addressed to all sites, false otherwise.
     */
    public boolean isPublic() {
        return this.destSiteId == ALL_SITES;
    }

    /**
     * @return true if this ISM was addressed to one specific site, false
     *         otherwise.
     */
    public boolean isPrivate() {
        return this.destSiteId != ALL_SITES;
    }

    /**
     * @return true if this ISM was sent by the Coordinator, false otherwise.
     */
    public boolean isFromCoordinator() {
	return this.sourceSiteId == RECIPROCAL_NET_COORDINATOR;
    }

    public boolean isFrom(int sourceSiteId) {
	return this.sourceSiteId == sourceSiteId;
    }

    public boolean isTo(int destSiteId) {
	return this.destSiteId == destSiteId;
    }
}
