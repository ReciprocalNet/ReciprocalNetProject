/*
 * Reciprocal Net Project
 *
 * SiteCodeBasedADCGenerator.java
 *
 * 06-Jan-2006: jobollin wrote first draft
 * 30-Aug-2006: jobollin updated docs
 * 02-Nov-2006: jobollin made small documentation changes 
 */

package org.recipnet.site.wrapper;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.recipnet.common.SymmetryMatrix;
import org.recipnet.common.molecule.Atom;
import org.recipnet.common.molecule.AtomicMotionFactory;
import org.recipnet.common.molecule.Bond;
import org.recipnet.common.molecule.FractionalAtom;
import org.recipnet.common.molecule.ModelBuilder;
import org.recipnet.common.molecule.MolecularModel;
import org.recipnet.common.molecule.SiteCode;
import org.recipnet.common.molecule.SymmetryCode;
import org.recipnet.common.molecule.SymmetryContext;

/**
 * An {@code ADCGenerator} implementation that interprets atomic site codes
 * to map atoms to atom designator codes.  This mode supports the Site
 * Software's generation of ORTEP images with use of thermal parameters from
 * CIF and the new site codes added to the CRT specification.
 *   
 * @author jobollin
 * @version 0.9.0
 */
class SiteCodeBasedADCGenerator implements ADCGenerator {
    
    /**
     * The underlying molecular model to which ADCs generated by this
     * generator will refer
     */
    private final MolecularModel<FractionalAtom, Bond<FractionalAtom>>
            baseModel;

    /**
     * An array of the {@code  SymopContext} objects associated with each
     * symmetry operation recognized by this site code interpreter
     */
    private final SymopContext[] contexts;

    /**
     * Initializes a {@code SiteCodeBasedADCGenerator} with the specified
     * base model and symmetry operation contexts
     * 
     * @param  baseModel the {@code MolecularModel&lt;FractionalAtom,
     *         Bond&lt;FractionalAtom&gt;&gt;} to use as the base model; should
     *         already be symmetry-reduced if necessary; should not be
     *         {@code null}
     * @param  contexts a {@code SymopContext[]} containing the symmetry
     *         operation contexts necessary to properly interpret the site codes
     *         that this generator is expected to handle; should not be
     *         {@code null} or contain {@code null} elements
     */
    private SiteCodeBasedADCGenerator(
            MolecularModel<FractionalAtom, Bond<FractionalAtom>> baseModel,
            SymopContext[] contexts) {
        
        assert baseModel != null;
        assert contexts != null;
        
        this.baseModel = baseModel;
        this.contexts = contexts;
    }
    
    /**
     * Creates a {@code SequenceBasedADCGenerator} based on the specified
     * model.  The provided model is not retained by the new ADC generator;
     * instead it is copied, imposing symmetry reduction if necessary.
     * 
     * @param  model a {@code MolecularModel&lt;FractionalAtom,
     *         Bond&lt;FractionalAtom&gt;&gt;} that will be used to create
     *         this generator's base model.  This model itself will not be
     *         modified or retained.  It should not be {@code null}
     *         
     * @return a {@code SiteCodeBasedADCGenerator} based on the specified model
     * 
     * @throws IllegalArgumentException if the provided model is not a suitable
     *         basis for a {@code SiteCodeBasedADCGenerator}; in particular,
     *         if it contains duplicate atom labels or if it contains too many
     *         symmetry operations for ORTEP but none are pure translations
     */
    public static SiteCodeBasedADCGenerator forModel(
            MolecularModel<FractionalAtom, Bond<FractionalAtom>> model) {
        Map<String, Integer> atomSiteLabelMap = new HashMap<String, Integer>();
        Collection<SymmetryMatrix> symops = model.getSymmetryOperations();
        List<SymopContext> contextList = new ArrayList<SymopContext>();
        MolecularModel<FractionalAtom, Bond<FractionalAtom>> reducedModel;
        String siteCodeDelim = "\\" + String.valueOf(SiteCode.DELIM);

        // Build a map from atom labels to the corresponding atom indices
        for (Atom atom : model.getAtoms()) {
            String siteTag = atom.getSiteTag();
            String siteLabel = ((siteTag == null)
                    ? guessAtomSiteLabel(atom.getLabel())
                    : siteTag.split(siteCodeDelim, 2)[0]);

            if (atomSiteLabelMap.containsKey(siteLabel)) {
                throw new IllegalArgumentException("Duplicate atom site label: "
                        + siteLabel);
            }
            atomSiteLabelMap.put(siteLabel, 1 + atomSiteLabelMap.size());
        }

        /*
         * Construct the reduced model (if necessary) and symmetry context list
         */
        if (symops.size() <= OrtepInputMaker.ORTEP_MAX_SYMMETRY) {

            // The symmetry does not require reduction

            // Add the identity if there are otherwise no operations
            if (symops.size() == 0) {
                symops.add(SymmetryMatrix.IDENTITY);
            }

            // Create a copy of the model for the new OrtepInputMaker's use
            reducedModel = new MolecularModel<FractionalAtom,
                    Bond<FractionalAtom>>(
                            model.getAtoms(), model.getBonds());
            for (SymmetryMatrix matrix : symops) {
                contextList.add(new SymopContext(1 + contextList.size(),
                        atomSiteLabelMap));
                reducedModel.addSymmetryOperation(matrix);
            }
        } else {

            /*
             * Need to apply a symmetry reduction
             */
            
            /*
             * A map from site labels to atom indices among the duplicate atoms:
             */
            Map<String, Integer> duplicateLabelMap
                    = new HashMap<String, Integer>();

            /*
             * A list of the matrices of the symmetry operations to exclude from
             * the symmetry-reduced model, in normalized form:
             */
            List<SymmetryMatrix> removalList = new ArrayList<SymmetryMatrix>();

            /*
             * A list of the product of each symmetry matrix included in the
             * reduced-symmetry model with the inverse matrix of the operation
             * removed from the base model to effect symmetry reduction.  The
             * normalized versions of these matrices are exactly those in the
             * removalList, in the same order, but these unnormalized versions
             * are required to compute ADC shifts relative to the retained
             * symmetry operations and duplicated atoms:
             */
            List<SymmetryMatrix> productList = new ArrayList<SymmetryMatrix>();

            /*
             * An atomic motion factory used in constructing duplicate atoms:
             */
            AtomicMotionFactory motionFactory
                    = new AtomicMotionFactory(model.getCell());

            // The matrix of the base operation to remove from the model:
            SymmetryMatrix toRemove = null;

            // A work array for computing shifts to add to ADCs:
            int[] shifts = new int[3];

            /*
             * index among the original symmetry operations of the base matrix
             * to remove: 
             */
            int toRemoveIndex = -1;

            /*
             * index among the reduced symmetry operations of the identity
             * operation:
             */
            int identityIndex = -1;

            // The reduced model starts with all the original atoms
            reducedModel
                    = new MolecularModel<FractionalAtom, Bond<FractionalAtom>>(
                            model.getAtoms(),
                            Collections.<Bond<FractionalAtom>> emptyList());

            /*
             * Construct an alternative label map referring to copies of the
             * original atoms
             */
            for (Map.Entry<String, Integer> entry : atomSiteLabelMap.entrySet()) {
                duplicateLabelMap.put(entry.getKey(),
                        (entry.getValue() + atomSiteLabelMap.size()));
            }

            /*
             * Find a translation to remove to reduce the symmetry. There must
             * be one if the symmetry operations describe a valid space group
             * with > 96 operations.
             */
            for (SymmetryMatrix matrix : symops) {
                if ((matrix.getType() == SymmetryMatrix.Type.TRANSLATION)
                        && (!matrix.normalize().equals(
                                SymmetryMatrix.IDENTITY))) {
                    toRemove = matrix;
                    break;
                }
            }
            if (toRemove == null) {
                throw new IllegalArgumentException("Invalid model symmetry: "
                        + "duplicate or incorrect operations");
            }

            // Add duplicate atoms to the model
            for (FractionalAtom atom : model.getAtoms()) {
                reducedModel.addAtom(ModelBuilder.transformAtom(atom, toRemove,
                        motionFactory));
            }

            // Map symops from the original model to the symmetry-reduced one
            for (SymmetryMatrix matrix : symops) {
                SymmetryMatrix normalizedMatrix = matrix.normalize();

                if (normalizedMatrix.equals(SymmetryMatrix.IDENTITY)) {

                    /*
                     * The identity operation gets slightly special treatment
                     * because it is necessary to remember its corresponding
                     * index in the product list
                     */
                    identityIndex = productList.size();
                    contextList.add(new SymopContext(identityIndex + 1,
                            atomSiteLabelMap));
                    reducedModel.addSymmetryOperation(matrix);
                    productList.add(toRemove.inverse());
                    removalList.add(toRemove.inverse().normalize());
                } else if (matrix == toRemove) {

                    /*
                     * insert a place holder into the context list because we
                     * need the identity operation's product matrix to compute
                     * the correct entry, and we can't be certain of having it
                     * yet.
                     */
                    toRemoveIndex = contextList.size();
                    contextList.add(null);
                } else {
                    int removalIndex = removalList.indexOf(normalizedMatrix);
                    
                    if (removalIndex < 0) {
    
                        /*
                         * This operation is not yet accounted for; add it
                         */
    
                        SymmetryMatrix product
                                = matrix.times(toRemove.inverse(), false);
    
                        contextList.add(new SymopContext(removalList.size() + 1,
                                atomSiteLabelMap));
                        reducedModel.addSymmetryOperation(matrix);
                        productList.add(product);
                        removalList.add(product.normalize());
                    } else {
    
                        /*
                         * This operation is already accounted for by a
                         * combination of a previous operation and the atom
                         * duplication; store enough information to duplicate
                         * this operation's effect
                         */
    
                        int[] targetTranslations = matrix.getTranslationVector();
                        int[] sourceTranslations
                                = productList.get(removalIndex).getTranslationVector();
    
                        /*
                         * the productList entry is expected to be the same as
                         * the current operation except possibly for some number
                         * of unit translations -- figure out which and how many
                         */
                        for (int i = 0; i < shifts.length; i++) {
                            int twelfths = targetTranslations[i]
                                    - sourceTranslations[i];
    
                            assert ((twelfths % 12) == 0);
    
                            shifts[i] = (twelfths / 12);
                        }
    
                        contextList.add(new SymopContext(removalIndex + 1, shifts,
                                duplicateLabelMap));
                    }
                }
            }

            /*
             * Fix up the symop context for the base removed operation, which
             * earlier was filled with a place holder; this is necessary to
             * account for the possibility that unit translations need to be
             * applied to the duplicate atoms referred to the identity operation
             */
            {
                int[] targetTranslations = toRemove.getTranslationVector();
                int[] sourceTranslations
                        = productList.get(identityIndex).getTranslationVector();

                for (int i = 0; i < shifts.length; i++) {
                    int twelfths = targetTranslations[i]
                            - sourceTranslations[i];

                    assert ((twelfths % 12) == 0);

                    shifts[i] = (twelfths / 12);
                }

                contextList.set(toRemoveIndex, new SymopContext(
                        identityIndex + 1, shifts, duplicateLabelMap));
            }
        }
        
        // Assign the original model's unit cell to the reduced model
        reducedModel.setCell(model.getCell());
        
        return new SiteCodeBasedADCGenerator(reducedModel,
                contextList.toArray(new SymopContext[contextList.size()]));
    }
    
    /**
     * {@inheritDoc}
     * 
     * @see ADCGenerator#getBaseModel()
     */
    public MolecularModel<FractionalAtom, Bond<FractionalAtom>> getBaseModel() {
        return baseModel;
    }
    
    /**
     * {@inheritDoc}.  This version always returns {@code true}.
     * 
     * @see ADCGenerator#usesModelSymmetry()
     */
    public boolean usesModelSymmetry() {
        return true;
    }
    
    /**
     * {@inheritDoc}.  This version uses the input atoms' site codes, if
     * available, in determining the corresponding ADCs; if site codes are not
     * available then an attempt is made to guess appropriate codes, assuming
     * the identity operation for the symmetry part.
     * 
     * @see ADCGenerator#createADCMap(List)
     */
    public Map<Atom, AtomDesignatorCode> createADCMap(
            List<? extends Atom> atoms) {
        SymmetryContext ortepSymmetry = new SymmetryContext(
                baseModel.getSymmetryOperations());
        SymmetryCode identityCode = ortepSymmetry.getIdentityCode();
        int maxSymop = ortepSymmetry.getOperationCount();
        Map<Atom, AtomDesignatorCode> adcMap
                = new HashMap<Atom, AtomDesignatorCode>(); 
        
        // Find the ADC for each atom
        for (Atom modelAtom : atoms) {

            // Determine the site code for the atom
            String tag = modelAtom.getSiteTag();

            SiteCode site = ((tag == null)
                    ? new SiteCode(guessAtomSiteLabel(modelAtom.getLabel()),
                            identityCode)
                    : SiteCode.valueOf(tag, identityCode));
            
            // Extract site label and symmetry code from the site code
            SymmetryCode symmCode = site.getSymmetryCode();

            // Verify symmetry code
            if (symmCode.getOperationIndex() > maxSymop) {
                throw new IllegalArgumentException(
                        "Invalid symmetry code for the available symmetry: "
                                + symmCode);
            } else {
                adcMap.put(modelAtom, interpretSiteCode(site));
            }
        }
        
        return adcMap;
    }
    
    /**
     * Attempts to guess the CIF atom site label corresponding to the specified
     * atom label by removing any text following the last closing parenthesis
     * and then removing all remaining parentheses, spaces, and tabs
     * 
     * @param  atomLabel the label for which a corresponding CIF atom site
     *         label should be guessed, typically from an atom of a molecular
     *         model read from a CRT file
     *         
     * @return the guessed CIF site label, or {@code null} if
     *         {@code crtAtomLabel} is {@code null}
     */
    private static String guessAtomSiteLabel(String atomLabel) {
        if (atomLabel == null) {
            return null;
        } else {
            return atomLabel.replaceFirst("\\((.*)\\).+", "$1").replaceAll(
                    "[() \t]+", "");
        }
    }
    
    /**
     * Interprets a {@code SiteCode} according to this ORTEP input maker's
     * configuration to produce a corresponding atom designator code
     * 
     * @param  code the {@code SiteCode} to interpret
     * 
     * @return an {@code AtomDesignatorCode} representing the interpreted ADC
     * 
     * @throws IllegalArgumentException if the site label associated with the
     *         specified site code does not correspond to an atom known to
     *         this interpreter or if the symmetry operation number included
     *         in the code is not supported by this interpreter
     */
    private AtomDesignatorCode interpretSiteCode(SiteCode code) {
        SymmetryCode symmetry = code.getSymmetryCode();

        try {
            SymopContext context = contexts[symmetry.getOperationIndex() - 1];
            String siteLabel = code.getSiteLabel();
            int[] translations = symmetry.getTranslations();

            // Shift the translation codes as necessary for the context
            context.adjustTranslations(translations);

            /*
             * Create and return an appropriate AtomDesignatorCode, validating
             * the site label in the process
             */
            return new AtomDesignatorCode(context.getAtomIndex(siteLabel),
                    translations, context.getOperationIndex());
        } catch (IndexOutOfBoundsException ioobe) {
            throw new IllegalArgumentException(
                    "Unsupported symmetry operation number: "
                            + symmetry.getOperationIndex());
        }
    }
}